<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Integrated Project Management Tools (Fixed)</title>
  <style>
    /* Common Styles */
    body {
      font-family: sans-serif;
      margin: 20px;
      background: #f7f7f7;
    }
    h1, h2, h3 {
      color: #333;
    }
    .container {
      background: #fff;
      padding: 20px;
      margin-bottom: 40px;
      border: 1px solid #ddd;
      border-radius: 8px;
      max-width: 1000px;
      margin: auto;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
    }
    button {
      cursor: pointer;
    }
    /* Tab Navigation */
    .tabs {
      display: flex;
      border-bottom: 1px solid #ccc;
      margin-bottom: 20px;
    }
    .tab-button {
      flex: 1;
      padding: 10px;
      text-align: center;
      background: #e0e0e0;
      border: none;
      outline: none;
      transition: background 0.3s;
    }
    .tab-button.active {
      background: #fff;
      border-bottom: 3px solid #007BFF;
      font-weight: bold;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    /* Tool 1: Network Diagram */
    #activitiesTable {
      border-collapse: collapse;
      margin-bottom: 1em;
      background: #fff;
    }
    #activitiesTable th, #activitiesTable td {
      border: 1px solid #ccc;
      padding: 0.3em;
    }
    #activitiesTable input, #activitiesTable select {
      width: 95%;
      box-sizing: border-box;
    }
    #diagram {
      border: 1px solid #ccc;
      background: #fafafa;
      margin-bottom: 1em;
    }
    .activity-circle {
      fill: white;
      stroke: #333;
      stroke-width: 1.5px;
    }
    .activity-label {
      font-size: 14px;
      text-anchor: middle;
      dominant-baseline: middle;
      font-weight: bold;
    }
    .activity-time {
      font-size: 12px;
      text-anchor: middle;
      fill: #555;
    }
    .arrow-line {
      stroke: #555;
      stroke-width: 1.5px;
      fill: none;
    }
    .arrow-line.critical {
      stroke: red;
      stroke-width: 2px;
    }
    .arrow-label {
      font-size: 12px;
      fill: #666;
    }
    #pathsOutput {
      white-space: pre;
      background: #fff;
      padding: 0.8em;
      border: 1px solid #ccc;
    }
    #jsonOutput {
      width: 90%;
      height: 80px;
      margin-top: 1em;
      padding: 8px;
      font-family: monospace;
      box-sizing: border-box;
      border: 1px solid #ccc;
      background: #fff;
    }
    #riskInsightsOutput {
      white-space: pre;
      background: #fff;
      padding: 0.8em;
      border: 1px solid #ccc;
      margin-top: 1em;
    }
    /* Tool 2: Advanced Scheduling / MC Simulator */
    #histogramCanvas2 {
      border: 1px solid #ccc;
      margin-top: 1em;
    }
    .slider-container {
      margin-top: 1em;
      background: #f9f9f9;
      border: 1px solid #ccc;
      padding: 0.5em;
      border-radius: 4px;
    }
    .slider-container label {
      margin-right: 0.5em;
      font-weight: bold;
    }
    .slider-value {
      font-weight: bold;
      margin-left: 0.5em;
    }
    .percentile-text {
      margin-top: 0.5em;
      font-style: italic;
      color: #333;
    }
    /* Tool 3: Resources Tool */
    textarea {
      width: 100%;
      height: 100px;
      padding: 8px;
      box-sizing: border-box;
      font-family: monospace;
      margin-bottom: 1em;
    }
    textarea.small-textarea {
      height: auto !important;
      padding: 4px;
      margin-bottom: 0.5em;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1em;
      font-size: 0.95em;
    }
    table, th, td {
      border: 1px solid #ccc;
      padding: 0.4em;
      text-align: left;
      vertical-align: middle;
    }
    th {
      background: #f0f0f0;
    }
    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 95%;
      padding: 4px;
      box-sizing: border-box;
    }
    .assignments-container {
      display: flex;
      flex-direction: column;
    }
    .assignment-row {
      display: flex;
      align-items: center;
      margin-bottom: 4px;
    }
    .assignment-row select {
      width: auto;
      margin-right: 8px;
    }
    .assignment-row input[type="number"] {
      width: 60px;
      margin-right: 8px;
    }
    button {
      padding: 8px 16px;
      margin: 5px 2px;
      background-color: #007BFF;
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 4px;
    }
    button:hover {
      background-color: #0056b3;
    }
    .warn {
      color: red;
      font-weight: bold;
    }
    #ganttContainer {
      width: 100%;
      overflow-x: auto;
      border: 1px solid #ccc;
      background: #fafafa;
      margin-top: 1em;
    }
    #ganttChart {
      display: block;
    }
    .task-bar {
      stroke-width: 1;
      cursor: pointer;
    }
    .task-bar.noncritical {
      fill: #2196F3;
      stroke: #1976D2;
    }
    .task-bar.critical {
      fill: #F44336;
      stroke: #C62828;
    }
    .bar-text {
      font-size: 10px;
      fill: #000;
      pointer-events: none;
    }
    .task-text {
      font-size: 12px;
      fill: #000;
      text-anchor: start;
    }
    .dep-line {
      stroke: #555;
      stroke-width: 1;
      fill: none;
    }
    #overallocationOutput {
      background: #ffe6e6;
      border: 1px solid #ffa5a5;
      padding: 10px;
      margin-top: 1em;
      display: none;
    }
    /* Modal for editing tasks */
    #editModal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #fff;
      border: 2px solid #333;
      border-radius: 6px;
      padding: 20px;
      width: 400px;
      max-width: 90%;
      display: none;
      z-index: 9999;
    }
    #editModal h3 {
      margin-top: 0;
    }
    #modalOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      z-index: 9998;
    }
    /* Risk JSON output box for Resources tool */
    #riskJsonOutputContainer {
      display: none;
      border: 1px solid #ccc;
      padding: 10px;
      margin-top: 1em;
      background: #f9f9f9;
    }
    #riskJsonOutput {
      width: 100%;
      height: 80px;
      font-family: monospace;
      resize: none;
    }
    #copyRiskJsonBtn {
      margin-top: 5px;
      padding: 6px 12px;
      background-color: #28a745;
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 4px;
    }
    #copyRiskJsonBtn:hover {
      background-color: #218838;
    }
    /* Tool 4: Risk Assessment (Tab 4) */
    #riskTable {
      width: 600px;
      max-width: 100%;
      margin-bottom: 1em;
    }
    #riskTable th, #riskTable td {
      border: 1px solid #ccc;
      padding: 0.5em;
      text-align: center;
    }
    input[type="text"], input[type="number"] {
      width: 100%;
      box-sizing: border-box;
    }
    .risk-btn {
      background: #0066cc;
      color: #fff;
      border: none;
      border-radius: 3px;
      padding: 0.5em 1em;
    }
    .risk-btn:hover {
      background: #0055a3;
    }
    .calc-btn {
      background: #ff9900;
      color: #fff;
      border: none;
      border-radius: 3px;
      padding: 0.4em 0.8em;
      margin-left: 4px;
    }
    .calc-btn:hover {
      background: #cc7a00;
    }
    #heatmapContainer {
      margin-top: 1em;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      display: block;
      width: fit-content;
      max-width: 100%;
      margin-bottom: 1em;
    }
  </style>
</head>
<body>
  <!-- Tab Navigation -->
  <div class="tabs">
    <button class="tab-button active" data-tab="tab1">Network Diagram</button>
    <button class="tab-button" data-tab="tab2">Advanced Scheduling</button>
    <button class="tab-button" data-tab="tab3">Resources</button>
    <button class="tab-button" data-tab="tab4">Risk Assessment</button>
  </div>

  <!-- Tab 1: Network Diagram with Critical Path Highlighting -->
  <div id="tab1" class="tab-content active">
    <button id="backButton1" onclick="window.location.href='https://projectmanagerhelper.com'">Back to Main Page</button>
    <h1>Network Diagram with Critical Path Highlighting</h1>
    <p>
      Enter your activities below (name, predecessors, duration). For each row, select a
      <strong>Dependency Type</strong> (FS default) and enter a <strong>Lead/Lag</strong> (days).
      If multiple predecessors are comma‑separated, the same type/lag applies to all.
      Then click <strong>Generate Diagram</strong>.
    </p>
    <table id="activitiesTable">
      <thead>
        <tr>
          <th>Activity</th>
          <th>Predecessors<br>(comma‑separated)</th>
          <th>Duration</th>
          <th>Dependency Type</th>
          <th>Lead/Lag</th>
        </tr>
      </thead>
      <tbody>
        <!-- Example rows -->
        <tr>
          <td><input type="text" value="A" /></td>
          <td><input type="text" value="" /></td>
          <td><input type="number" value="4" /></td>
          <td>
            <select>
              <option value="FS" selected>FS</option>
              <option value="SS">SS</option>
              <option value="FF">FF</option>
              <option value="SF">SF</option>
            </select>
          </td>
          <td><input type="number" value="0" /></td>
        </tr>
        <tr>
          <td><input type="text" value="B" /></td>
          <td><input type="text" value="" /></td>
          <td><input type="number" value="7" /></td>
          <td>
            <select>
              <option value="FS" selected>FS</option>
              <option value="SS">SS</option>
              <option value="FF">FF</option>
              <option value="SF">SF</option>
            </select>
          </td>
          <td><input type="number" value="0" /></td>
        </tr>
        <tr>
          <td><input type="text" value="C" /></td>
          <td><input type="text" value="A,B" /></td>
          <td><input type="number" value="2" /></td>
          <td>
            <select>
              <option value="FS" selected>FS</option>
              <option value="SS">SS</option>
              <option value="FF">FF</option>
              <option value="SF">SF</option>
            </select>
          </td>
          <td><input type="number" value="0" /></td>
        </tr>
        <tr>
          <td><input type="text" value="D" /></td>
          <td><input type="text" value="B" /></td>
          <td><input type="number" value="5" /></td>
          <td>
            <select>
              <option value="FS" selected>FS</option>
              <option value="SS">SS</option>
              <option value="FF">FF</option>
              <option value="SF">SF</option>
            </select>
          </td>
          <td><input type="number" value="0" /></td>
        </tr>
        <tr>
          <td><input type="text" value="E" /></td>
          <td><input type="text" value="C" /></td>
          <td><input type="number" value="10" /></td>
          <td>
            <select>
              <option value="FS" selected>FS</option>
              <option value="SS">SS</option>
              <option value="FF">FF</option>
              <option value="SF">SF</option>
            </select>
          </td>
          <td><input type="number" value="0" /></td>
        </tr>
        <tr>
          <td><input type="text" value="F" /></td>
          <td><input type="text" value="C,D" /></td>
          <td><input type="number" value="13" /></td>
          <td>
            <select>
              <option value="FS" selected>FS</option>
              <option value="SS">SS</option>
              <option value="FF">FF</option>
              <option value="SF">SF</option>
            </select>
          </td>
          <td><input type="number" value="0" /></td>
        </tr>
        <tr>
          <td><input type="text" value="G" /></td>
          <td><input type="text" value="E,F" /></td>
          <td><input type="number" value="4" /></td>
          <td>
            <select>
              <option value="FS" selected>FS</option>
              <option value="SS">SS</option>
              <option value="FF">FF</option>
              <option value="SF">SF</option>
            </select>
          </td>
          <td><input type="number" value="0" /></td>
        </tr>
      </tbody>
    </table>
    <button id="addRowBtn">Add Row</button>
    <button id="removeRowBtn">Remove Row</button>
    <button id="generateBtn">Generate Diagram</button>
    <svg id="diagram" width="900" height="600"></svg>
    <div id="pathsOutput"></div>
    <button id="copyJsonBtn">Copy JSON Output</button>
    <textarea id="jsonOutput" readonly placeholder="JSON output will appear here..."></textarea>
    <!-- NEW: Generate Risk Insights Button -->
    <button id="generateRiskInsightsBtn">Generate Risk Insights</button>
    <div id="riskInsightsOutput"></div>
    <script>
      /***************
       * Tool 1 JS (Network Diagram)
       ***************/
      const RADIUS = 20, X_GAP = 160, Y_GAP = 100, MARGIN_X = 60, MARGIN_Y = 60;
      let tasks = {}, edgesMap = {}, allActivities = [];

      // Add/Remove Row
      document.getElementById("addRowBtn").addEventListener("click", () => {
        const tbody = document.getElementById("activitiesTable").querySelector("tbody");
        const row = document.createElement("tr");
        row.innerHTML = `
          <td><input type="text" value="" /></td>
          <td><input type="text" value="" /></td>
          <td><input type="number" value="5" /></td>
          <td>
            <select>
              <option value="FS" selected>FS</option>
              <option value="SS">SS</option>
              <option value="FF">FF</option>
              <option value="SF">SF</option>
            </select>
          </td>
          <td><input type="number" value="0" /></td>
        `;
        tbody.appendChild(row);
      });
      document.getElementById("removeRowBtn").addEventListener("click", () => {
        const tbody = document.getElementById("activitiesTable").querySelector("tbody");
        if (tbody.rows.length > 0) tbody.removeChild(tbody.lastElementChild);
      });

      document.getElementById("generateBtn").addEventListener("click", () => {
        readTableData();
        computeTopologicalLevels();
        doForwardPass();
        doBackwardPass();
        drawDiagram();
        highlightCriticalEdges();
        let concurrencyLines = showConcurrencySummary();
        let naiveLines = showNaivePathsWithLag();
        document.getElementById("pathsOutput").textContent =
          concurrencyLines.join("\n") + "\n\n" + naiveLines.join("\n");
        generateJSONOutput();

        // ***** FIX #1: Save JSON in localStorage so Tab 2 & 3 can auto-load
        localStorage.setItem("networkJSON", document.getElementById("jsonOutput").value);
      });

      function readTableData() {
        tasks = {};
        edgesMap = {};
        allActivities = [];
        const rows = document.querySelectorAll("#activitiesTable tbody tr");
        rows.forEach(row => {
          const cells = row.querySelectorAll("td");
          if (cells.length < 5) return;
          const name = cells[0].querySelector("input").value.trim();
          if (!name) return;
          const predsStr = cells[1].querySelector("input").value.trim();
          const duration = parseFloat(cells[2].querySelector("input").value.trim() || "0");
          const depType  = cells[3].querySelector("select").value;
          const leadLag  = parseFloat(cells[4].querySelector("input").value.trim() || "0");
          if (!tasks[name]) {
            tasks[name] = { name, duration, preds: [], succ: [], level: 0, ES: 0, EF: 0, LS: 0, LF: 0, deps: [] };
          }
          if (predsStr) {
            const pList = predsStr.split(",").map(s => s.trim()).filter(Boolean);
            tasks[name].preds = pList;
            pList.forEach(p => {
              tasks[name].deps.push({ predecessor: p, type: depType || "FS", lag: leadLag || 0 });
            });
          }
          tasks[name].duration = duration;
        });

        for (let t in tasks) {
          tasks[t].inDegree = tasks[t].preds.length;
          tasks[t].succ = [];
        }
        for (let t in tasks) {
          tasks[t].preds.forEach(p => {
            if (!tasks[p]) {
              tasks[p] = { name: p, duration: 0, preds: [], succ: [], level: 0, ES: 0, EF: 0, LS: 0, LF: 0, deps: [] };
            }
            tasks[p].succ.push(t);
          });
        }
      }

      function computeTopologicalLevels() {
        let inDegCopy = {}, queue = [];
        for (let t in tasks) {
          inDegCopy[t] = tasks[t].inDegree;
          if (inDegCopy[t] === 0) queue.push(t);
        }
        while (queue.length > 0) {
          let current = queue.shift();
          allActivities.push(current);
          let curLevel = tasks[current].level;
          tasks[current].succ.forEach(s => {
            inDegCopy[s]--;
            tasks[s].level = Math.max(tasks[s].level, curLevel + 1);
            if (inDegCopy[s] === 0) queue.push(s);
          });
        }
      }

      function doForwardPass() {
        if (allActivities.length < Object.keys(tasks).length) {
          for (let t in tasks) {
            if (!allActivities.includes(t)) allActivities.push(t);
          }
        }
        for (let t in tasks) {
          if (tasks[t].inDegree === 0) {
            tasks[t].ES = 0;
            tasks[t].EF = tasks[t].duration;
          }
        }
        allActivities.forEach(actName => {
          let act = tasks[actName];
          if (!act.deps || act.deps.length === 0) return;
          let newES = act.ES;
          act.deps.forEach(dep => {
            let pred = tasks[dep.predecessor];
            if (!pred) return;
            let candidate = 0;
            switch(dep.type) {
              case "FS": candidate = pred.EF + dep.lag; break;
              case "SS": candidate = pred.ES + dep.lag; break;
              case "FF": candidate = pred.EF + dep.lag - act.duration; break;
              case "SF": candidate = pred.ES + dep.lag - act.duration; break;
            }
            if (candidate > newES) newES = candidate;
          });
          act.ES = Math.max(act.ES, newES);
          act.EF = act.ES + act.duration;
        });
      }

      function doBackwardPass() {
        let endNodes = Object.values(tasks).filter(t => t.succ.length === 0).map(t => t.name);
        let maxEF = 0;
        endNodes.forEach(n => { if (tasks[n].EF > maxEF) maxEF = tasks[n].EF; });
        let reverseOrder = allActivities.slice().reverse();
        endNodes.forEach(n => {
          tasks[n].LF = maxEF;
          tasks[n].LS = tasks[n].LF - tasks[n].duration;
        });
        reverseOrder.forEach(actName => {
          let act = tasks[actName];
          if (act.succ.length === 0) {
            if (act.LF === 0) {
              act.LF = act.EF;
              act.LS = act.LF - act.duration;
            }
            return;
          }
          let newLF = Number.MAX_VALUE;
          act.succ.forEach(succName => {
            let succ = tasks[succName];
            let depObj = succ.deps.find(d => d.predecessor === actName);
            if (!depObj) return;
            let candidateLF = 0;
            switch(depObj.type) {
              case "FS": candidateLF = succ.LS - depObj.lag; break;
              case "SS": candidateLF = (succ.LS - depObj.lag) + act.duration; break;
              case "FF": candidateLF = succ.LF - depObj.lag; break;
              case "SF": candidateLF = (succ.LF - depObj.lag) + act.duration; break;
            }
            if (candidateLF < newLF) newLF = candidateLF;
          });
          if (newLF === Number.MAX_VALUE) {
            act.LF = act.EF;
            act.LS = act.LF - act.duration;
          } else {
            act.LF = Math.min(act.LF || newLF, newLF);
            act.LS = act.LF - act.duration;
          }
        });
      }

      function drawDiagram() {
        const svg = document.getElementById("diagram");
        while (svg.firstChild) { svg.removeChild(svg.firstChild); }
        let levelMap = {}, maxLevel = 0;
        for (let t in tasks) {
          let lvl = tasks[t].level;
          if (!levelMap[lvl]) levelMap[lvl] = [];
          levelMap[lvl].push(t);
          if (lvl > maxLevel) maxLevel = lvl;
        }
        for (let lvl = 0; lvl <= maxLevel; lvl++) {
          const tList = levelMap[lvl] || [];
          for (let i = 0; i < tList.length; i++) {
            let taskName = tList[i];
            tasks[taskName].x = MARGIN_X + lvl * X_GAP;
            tasks[taskName].y = MARGIN_Y + i * Y_GAP;
          }
        }
        let maxRow = 0;
        for (let lvl = 0; lvl <= maxLevel; lvl++) {
          if (levelMap[lvl] && levelMap[lvl].length > maxRow) maxRow = levelMap[lvl].length;
        }
        const width = (maxLevel + 1) * X_GAP + 2 * MARGIN_X;
        const height = maxRow * Y_GAP + 2 * MARGIN_Y;
        svg.setAttribute("width", width);
        svg.setAttribute("height", height);

        for (let t in tasks) {
          let act = tasks[t];
          act.deps.forEach(dep => {
            let px = tasks[dep.predecessor].x;
            let py = tasks[dep.predecessor].y;
            let edgeKey = dep.predecessor + "->" + t;
            drawArrow(svg, px, py, act.x, act.y, edgeKey, dep.type, dep.lag);
          });
        }
        for (let t in tasks) { drawNode(svg, tasks[t]); }
      }

      function drawArrow(svg, x1, y1, x2, y2, edgeKey, depType, lag) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("class", "arrow-line");
        line.setAttribute("marker-end", "url(#arrowhead)");
        svg.appendChild(line);
        edgesMap[edgeKey] = line;
        if (!document.getElementById("arrowhead")) {
          const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
          const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
          marker.setAttribute("id", "arrowhead");
          marker.setAttribute("viewBox", "0 0 10 10");
          marker.setAttribute("refX", "10");
          marker.setAttribute("refY", "5");
          marker.setAttribute("markerUnits", "strokeWidth");
          marker.setAttribute("markerWidth", "6");
          marker.setAttribute("markerHeight", "6");
          marker.setAttribute("orient", "auto");
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute("d", "M 0 0 L 10 5 L 0 10 z");
          path.setAttribute("fill", "#555");
          marker.appendChild(path);
          defs.appendChild(marker);
          svg.appendChild(defs);
        }
        const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2;
        let labelStr = depType;
        if (lag > 0) labelStr += "+" + lag;
        else if (lag < 0) labelStr += lag;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.setAttribute("class", "arrow-label");
        label.setAttribute("x", midX);
        label.setAttribute("y", midY - 5);
        label.setAttribute("text-anchor", "middle");
        label.textContent = labelStr;
        svg.appendChild(label);
      }

      function drawNode(svg, act) {
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", act.x);
        circle.setAttribute("cy", act.y);
        circle.setAttribute("r", RADIUS);
        circle.setAttribute("class", "activity-circle");
        svg.appendChild(circle);

        const durText = document.createElementNS("http://www.w3.org/2000/svg", "text");
        durText.setAttribute("x", act.x);
        durText.setAttribute("y", act.y - (RADIUS+8));
        durText.setAttribute("class", "activity-time");
        durText.textContent = act.duration;
        svg.appendChild(durText);

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", act.x);
        text.setAttribute("y", act.y);
        text.setAttribute("class", "activity-label");
        text.textContent = act.name;
        svg.appendChild(text);
      }

      function highlightCriticalEdges() {
        for (let t in tasks) {
          tasks[t].succ.forEach(succName => {
            let depObj = tasks[succName].deps.find(d => d.predecessor === t);
            if (!depObj) return;
            let act = tasks[t], succ = tasks[succName];
            let requiredStart = 0;
            switch(depObj.type) {
              case "FS": requiredStart = act.EF + depObj.lag; break;
              case "SS": requiredStart = act.ES + depObj.lag; break;
              case "FF": requiredStart = act.EF + depObj.lag - succ.duration; break;
              case "SF": requiredStart = act.ES + depObj.lag - succ.duration; break;
            }
            let actFloat = act.LS - act.ES;
            let succFloat = succ.LS - succ.ES;
            let edgeKey = t + "->" + succName;
            if (
              Math.abs(succ.ES - requiredStart) < 0.0001 &&
              Math.abs(actFloat) < 0.0001 &&
              Math.abs(succFloat) < 0.0001
            ) {
              if (edgesMap[edgeKey]) {
                edgesMap[edgeKey].classList.add("critical");
              }
            }
          });
        }
      }

      function showConcurrencySummary() {
        let lines = [];
        lines.push("Concurrency-based summary (ES, EF, LS, LF, Float):");
        for (let t in tasks) {
          let act = tasks[t];
          let floatVal = (act.LS - act.ES).toFixed(2);
          lines.push(`${act.name}: ES=${act.ES.toFixed(2)} EF=${act.EF.toFixed(2)} LS=${act.LS.toFixed(2)} LF=${act.LF.toFixed(2)} Float=${floatVal}`);
        }
        return lines;
      }

      function showNaivePathsWithLag() {
        let lines = [];
        lines.push("Naive Paths (Start -> End) with Durations (including lead/lag):");
        let startNodes = Object.values(tasks).filter(t => t.inDegree === 0).map(t => t.name);
        let allNaivePaths = [];
        startNodes.forEach(sn => { dfsNaive([sn], sn, {}); });

        function dfsNaive(pathSoFar, current, localTimes) {
          if (!localTimes[current]) {
            localTimes[current] = { start: 0, finish: tasks[current].duration };
          }
          if (tasks[current].succ.length === 0) {
            let finalFinish = localTimes[current].finish;
            allNaivePaths.push({ path: pathSoFar.slice(), total: finalFinish });
            return;
          }
          tasks[current].succ.forEach(succName => {
            let newPath = pathSoFar.slice();
            newPath.push(succName);
            let newTimes = JSON.parse(JSON.stringify(localTimes));
            let depObj = tasks[succName].deps.find(d => d.predecessor === current);
            if (!depObj) { depObj = { type: "FS", lag: 0 }; }
            let predStart = newTimes[current].start, predFinish = newTimes[current].finish;
            let nextStart = 0;
            switch(depObj.type) {
              case "FS": nextStart = predFinish + depObj.lag; break;
              case "SS": nextStart = predStart + depObj.lag; break;
              case "FF": nextStart = (predFinish + depObj.lag) - tasks[succName].duration; break;
              case "SF": nextStart = (predStart + depObj.lag) - tasks[succName].duration; break;
            }
            if (nextStart < 0) nextStart = 0;
            newTimes[succName] = {
              start: Math.max((newTimes[succName]?.start || 0), nextStart),
              finish: 0
            };
            newTimes[succName].finish = newTimes[succName].start + tasks[succName].duration;
            dfsNaive(newPath, succName, newTimes);
          });
        }

        if (allNaivePaths.length === 0) {
          lines.push("(No paths found or cyclical graph.)");
        } else {
          let maxDur = Math.max(...allNaivePaths.map(p => p.total));
          allNaivePaths.forEach(p => {
            let pathStr = p.path.join(" -> ");
            let critMark = (p.total === maxDur) ? " *CRITICAL*" : "";
            lines.push(`Path: ${pathStr} | Duration: ${p.total}${critMark}`);
          });
        }
        return lines;
      }

      function generateJSONOutput() {
        let maxFloat = 0;
        for (let t in tasks) {
          let fl = tasks[t].LS - tasks[t].ES;
          if (fl > maxFloat) { maxFloat = fl; }
        }
        if (maxFloat === 0) { maxFloat = 1; }
        let maxConn = 0;
        for (let t in tasks) {
          let conn = tasks[t].preds.length + tasks[t].succ.length;
          if (conn > maxConn) { maxConn = conn; }
        }
        if (maxConn === 0) { maxConn = 1; }

        let activities = [];
        for (let t in tasks) {
          let task = tasks[t];
          let floatVal = task.LS - task.ES;
          let floatRisk = (maxFloat - floatVal) / maxFloat;
          let connectivity = task.preds.length + task.succ.length;
          let connRisk = connectivity / maxConn;
          let riskScore = Math.round((0.6 * floatRisk + 0.4 * connRisk) * 10);
          riskScore = Math.max(1, Math.min(10, riskScore));
          let riskName = "Delay in " + task.name;
          activities.push({
            name: task.name,
            duration: task.duration,
            predecessors: task.deps.map(d => d.predecessor),
            dependencies: task.deps.map(d => ({ predecessor: d.predecessor, type: d.type, lag: d.lag })),
            suggestedRisk: riskScore,
            riskName: riskName
          });
        }
        const jsonStr = JSON.stringify(activities, null, 2);
        document.getElementById("jsonOutput").value = jsonStr;
      }

      // Generate Risk Insights button (Tab1 tweak)
      document.getElementById("generateRiskInsightsBtn").addEventListener("click", generateRiskInsights);
      function generateRiskInsights() {
        if (!tasks || Object.keys(tasks).length === 0) {
          alert("No tasks found. Please generate the diagram first.");
          return;
        }
        let maxFloat = 0;
        for (let t in tasks) {
          let fl = tasks[t].LS - tasks[t].ES;
          if (fl > maxFloat) { maxFloat = fl; }
        }
        if (maxFloat === 0) { maxFloat = 1; }
        let maxConn = 0;
        for (let t in tasks) {
          let conn = tasks[t].preds.length + tasks[t].succ.length;
          if (conn > maxConn) { maxConn = conn; }
        }
        if (maxConn === 0) { maxConn = 1; }
        let insights = "Risk Insights per Activity:\n\n";
        for (let t in tasks) {
          let act = tasks[t];
          let floatVal = act.LS - act.ES;
          let floatRisk = (maxFloat - floatVal) / maxFloat;
          let connectivity = act.preds.length + act.succ.length;
          let connRisk = connectivity / maxConn;
          let riskScore = Math.round((0.6 * floatRisk + 0.4 * connRisk) * 10);
          riskScore = Math.max(1, Math.min(10, riskScore));
          insights += `Activity ${act.name}:\n`;
          insights += `  - Duration: ${act.duration}\n`;
          insights += `  - Float: ${floatVal.toFixed(2)} (ES=${act.ES.toFixed(2)}, LS=${act.LS.toFixed(2)})\n`;
          insights += `  - Connectivity: ${act.preds.length} predecessor(s) + ${act.succ.length} successor(s) = ${connectivity}\n`;
          insights += `  - Suggested Risk Score: ${riskScore} (1 = Low Risk, 10 = High Risk)\n\n`;
        }
        insights += "Note: Impact is calculated based on float and connectivity (weights 0.6 and 0.4).";
        document.getElementById("riskInsightsOutput").textContent = insights;
      }
    </script>
  </div>
  <!-- End of Tab 1 -->

  <!-- Tab 2: Advanced Scheduling / Monte Carlo Simulator -->
  <div id="tab2" class="tab-content">
    <script>
      // ***** FIX #2a: Auto-load JSON from localStorage on Tab 2
      window.addEventListener("load", () => {
        const tab1JSON = localStorage.getItem("networkJSON");
        if(tab1JSON) {
          document.getElementById("networkJson2").value = tab1JSON;
        }
      });
    </script>

    <div class="container" id="networkContainer2">
      <h1>Monte Carlo Project Schedule Simulator</h1>
      <p>
        <strong>Option A:</strong> Paste the JSON output from your Network Diagram tool below, then click <em>Load Network</em>.<br>
        <strong>Option B:</strong> Or manually add activities and dependencies.
      </p>
      <textarea id="networkJson2" placeholder="Paste network JSON here..."></textarea>
      <button id="loadNetworkBtn2">Load Network</button>
    </div>

    <!-- Duration Adjustment Buttons -->
    <div id="applyAdjustments2" style="margin:1em 0;">
      <button id="apply10Btn2">Apply ±10% (Uniform)</button>
      <button id="apply20Btn2">Apply ±20% (Uniform)</button>
    </div>
    <!-- New buttons for PERT adjustment -->
    <div id="applyPertAdjustments2" style="margin:1em 0;">
      <button id="applyPert10Btn2">Apply ±10% (PERT)</button>
      <button id="applyPert20Btn2">Apply ±20% (PERT)</button>
    </div>

    <!-- Activity Distribution Configuration -->
    <div class="container" id="activityConfigContainer2">
      <h2>Activity Distribution Configuration</h2>
      <p>
        For each activity, choose a distribution type and enter its parameters (comma‑separated).<br>
        (For example, for normal: "mean,stdDev")
      </p>
      <button id="addActivityRowBtn2">Manual Add Activity</button>
      <button id="removeActivityRowBtn2">Remove Last Activity</button>
      <table id="activityConfigTable2">
        <thead>
          <tr>
            <th>Activity</th>
            <th>Base Duration</th>
            <th>Distribution</th>
            <th>Parameters</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows generated dynamically -->
        </tbody>
      </table>
    </div>

    <!-- Dependency Configuration -->
    <div class="container" id="dependencyConfigContainer2">
      <h2>Dependency Configuration</h2>
      <p>
        The table below is auto‑filled from your diagram’s JSON <code>dependencies</code> array,
        or you can <em>Manual Add Dependency</em> to create a row.
      </p>
      <button id="addDependencyRowBtn2">Manual Add Dependency</button>
      <button id="removeDependencyRowBtn2">Remove Last Dependency</button>
      <table id="dependencyTable2">
        <thead>
          <tr>
            <th>Activity</th>
            <th>Predecessor</th>
            <th>Dependency Type</th>
            <th>Lead/Lag (days)</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows generated dynamically -->
        </tbody>
      </table>
    </div>

    <!-- Simulation and Results -->
    <div class="container" id="simulationContainer2">
      <h2>Run Simulation</h2>
      <label for="numTrials2">Number of Trials:</label>
      <input type="number" id="numTrials2" value="5000" style="width:100px;" />
      <button id="runSimBtn2">Run Simulation</button>

      <div id="resultsArea2" style="display:none;">
        <div id="statsOutput2"></div>
        <canvas id="histogramCanvas2" width="600" height="350"></canvas>
        <div class="slider-container" id="sliderContainer2" style="display:none;">
          <label for="percentileSlider2">Percentile:</label>
          <input type="range" id="percentileSlider2" min="0" max="100" value="50" oninput="updatePercentile2()" />
          <span class="slider-value" id="percentileValue2">50</span>%
          <div class="stat-line">
            <span class="stat-label">Value at Percentile:</span>
            <span id="valAtPercentile2"></span>
          </div>
          <div class="percentile-text" id="percentileText2"></div>
        </div>
        <!-- New: Risk Report Generation Buttons -->
        <div style="margin-top:1em;">
          <button id="generateProjectRiskReportBtn2">Generate Project Risk Report</button>
          <button id="generateActivityRiskReportsBtn2">Generate Activity Risk Reports</button>
        </div>
      </div>
    </div>

    <script>

<!-- BEGIN REPLACEMENT CODE FOR TAB 2 -->
<div id="tab2" class="tab-content">
  <script>
    // On load, auto-populate network JSON from localStorage (from Tab 1)
    window.addEventListener("load", () => {
      const tab1JSON = localStorage.getItem("networkJSON");
      if (tab1JSON) {
        document.getElementById("networkJson2").value = tab1JSON;
      }
    });
  </script>

  <div class="container" id="networkContainer2">
    <h1>Monte Carlo Project Schedule Simulator</h1>
    <p>
      <strong>Option A:</strong> Paste the JSON output from your Network Diagram tool below, then click
      <em>Load Network</em>.<br>
      <strong>Option B:</strong> Or manually add activities and dependencies.
    </p>
    <textarea id="networkJson2" placeholder="Paste network JSON here..."></textarea>
    <button id="loadNetworkBtn2">Load Network</button>
  </div>

  <!-- Duration Adjustment Buttons -->
  <div id="applyAdjustments2" style="margin:1em 0;">
    <button id="apply10Btn2">Apply ±10% (Uniform)</button>
    <button id="apply20Btn2">Apply ±20% (Uniform)</button>
  </div>

  <!-- New buttons for PERT adjustment -->
  <div id="applyPertAdjustments2" style="margin:1em 0;">
    <button id="applyPert10Btn2">Apply ±10% (PERT)</button>
    <button id="applyPert20Btn2">Apply ±20% (PERT)</button>
  </div>

  <!-- Activity Distribution Configuration -->
  <div class="container" id="activityConfigContainer2">
    <h2>Activity Distribution Configuration</h2>
    <p>
      For each activity, choose a distribution type and enter its parameters (comma‑separated).<br>
      (For example, for normal: "mean,stdDev")
    </p>
    <button id="addActivityRowBtn2">Manual Add Activity</button>
    <button id="removeActivityRowBtn2">Remove Last Activity</button>
    <table id="activityConfigTable2">
      <thead>
        <tr>
          <th>Activity</th>
          <th>Base Duration</th>
          <th>Distribution</th>
          <th>Parameters</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows generated dynamically -->
      </tbody>
    </table>
  </div>

  <!-- Dependency Configuration -->
  <div class="container" id="dependencyConfigContainer2">
    <h2>Dependency Configuration</h2>
    <p>
      The table below is auto‑filled from your diagram’s JSON <code>dependencies</code> array,
      or you can <em>Manual Add Dependency</em> to create a row.
    </p>
    <button id="addDependencyRowBtn2">Manual Add Dependency</button>
    <button id="removeDependencyRowBtn2">Remove Last Dependency</button>
    <table id="dependencyTable2">
      <thead>
        <tr>
          <th>Activity</th>
          <th>Predecessor</th>
          <th>Dependency Type</th>
          <th>Lead/Lag (days)</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows generated dynamically -->
      </tbody>
    </table>
  </div>

  <!-- Simulation and Results -->
  <div class="container" id="simulationContainer2">
    <h2>Run Simulation</h2>
    <label for="numTrials2">Number of Trials:</label>
    <input type="number" id="numTrials2" value="5000" style="width:100px;" />
    <button id="runSimBtn2">Run Simulation</button>

    <div id="resultsArea2" style="display:none;">
      <div id="statsOutput2"></div>
      <canvas id="histogramCanvas2" width="600" height="350"></canvas>

      <div class="slider-container" id="sliderContainer2" style="display:none;">
        <label for="percentileSlider2">Percentile:</label>
        <input type="range" id="percentileSlider2" min="0" max="100" value="50" oninput="updatePercentile2()" />
        <span class="slider-value" id="percentileValue2">50</span>%
        <div class="stat-line">
          <span class="stat-label">Value at Percentile:</span>
          <span id="valAtPercentile2"></span>
        </div>
        <div class="percentile-text" id="percentileText2"></div>
      </div>

      <!-- New: Risk Report Generation Buttons -->
      <div style="margin-top:1em;">
        <button id="generateProjectRiskReportBtn2">Generate Project Risk Report</button>
        <button id="generateActivityRiskReportsBtn2">Generate Activity Risk Reports</button>
      </div>
    </div>
  </div>

  <script>
    /***************
     * Tool 2 JS (Advanced Scheduling / MC)
     ***************/

    let networkActivities2 = [], activityConfigs2 = [], dependencyConfigs2 = [], simulatedDurations2 = [];

    const distOptions2 = [
      { value: "triangular", label: "Triangular (min, mode, max)" },
      { value: "normal",     label: "Normal (mean, stdDev)" },
      { value: "uniform",    label: "Uniform (min, max)" },
      { value: "pert",       label: "PERT (optimistic, most likely, pessimistic)" },
      { value: "exponential", label: "Exponential (λ)" },
      { value: "lognormal",   label: "Lognormal (mu, sigma)" },
      { value: "weibull",     label: "Weibull (shape, scale)" },
      { value: "gamma",       label: "Gamma (shape, scale)" },
      { value: "poisson",     label: "Poisson (λ)" },
      { value: "binomial",    label: "Binomial (n, p)" }
    ];

    const dependencyTypes2 = [
      { value: "FS", label: "Finish-to-Start" },
      { value: "SS", label: "Start-to-Start" },
      { value: "FF", label: "Finish-to-Finish" },
      { value: "SF", label: "Start-to-Finish" }
    ];

    // ====== LOAD NETWORK FROM JSON (Tab 1) ======
    document.getElementById("loadNetworkBtn2").addEventListener("click", () => {
      const jsonText = document.getElementById("networkJson2").value;
      try {
        networkActivities2 = JSON.parse(jsonText);
      } catch (e) {
        alert("Invalid JSON.");
        return;
      }
      if (!Array.isArray(networkActivities2) || networkActivities2.length === 0) {
        alert("JSON must be an array.");
        return;
      }
      console.log("Loaded network activities (Tool 2):", networkActivities2);
      generateActivityConfigTable2();
      generateDependencyTable2();
    });

    // ====== GENERATE ACTIVITY CONFIG TABLE ======
    function generateActivityConfigTable2() {
      activityConfigs2 = [];
      const tbody = document.getElementById("activityConfigTable2").querySelector("tbody");
      tbody.innerHTML = "";

      // For each activity, create a "config" row
      networkActivities2.forEach(act => {
        const config = {
          name: act.name,
          base: act.duration,
          dist: "normal",
          params: []
        };
        // If the JSON has a suggestedRisk, store it
        if (act.suggestedRisk) {
          config.suggestedRisk = act.suggestedRisk;
        }
        activityConfigs2.push(config);
        addActivityRowToTable2(config);
      });
      console.log("Activity config table 2 done:", activityConfigs2);
    }

    function addActivityRowToTable2(cfg) {
      const tbody = document.getElementById("activityConfigTable2").querySelector("tbody");
      const tr = document.createElement("tr");

      // Activity name
      let tdName = document.createElement("td");
      let inputName = document.createElement("input");
      inputName.type = "text";
      inputName.value = cfg.name || "";
      inputName.addEventListener("input", e => {
        cfg.name = e.target.value.trim();
      });
      tdName.appendChild(inputName);
      tr.appendChild(tdName);

      // Base duration
      let tdBase = document.createElement("td");
      let inputBase = document.createElement("input");
      inputBase.type = "number";
      inputBase.value = cfg.base || 0;
      inputBase.addEventListener("input", e => {
        cfg.base = parseFloat(e.target.value) || 0;
      });
      tdBase.appendChild(inputBase);
      tr.appendChild(tdBase);

      // Distribution select
      let tdDist = document.createElement("td");
      let selectDist = document.createElement("select");
      distOptions2.forEach(opt => {
        const option = document.createElement("option");
        option.value = opt.value;
        option.textContent = opt.label;
        if (opt.value === cfg.dist) option.selected = true;
        selectDist.appendChild(option);
      });
      selectDist.addEventListener("change", e => {
        cfg.dist = e.target.value;
      });
      tdDist.appendChild(selectDist);
      tr.appendChild(tdDist);

      // Parameters input
      let tdParams = document.createElement("td");
      let inputParams = document.createElement("input");
      inputParams.type = "text";
      inputParams.placeholder = "e.g. mean,stdDev";
      if (cfg.params && cfg.params.length > 0) {
        inputParams.value = cfg.params.join(",");
      }
      inputParams.addEventListener("input", e => {
        cfg.params = e.target.value
          .split(",")
          .map(s => parseFloat(s.trim()))
          .filter(n => !isNaN(n));
      });
      tdParams.appendChild(inputParams);
      tr.appendChild(tdParams);

      tbody.appendChild(tr);
    }

    document.getElementById("addActivityRowBtn2").addEventListener("click", () => {
      const newCfg = { name: "", base: 0, dist: "normal", params: [] };
      activityConfigs2.push(newCfg);
      addActivityRowToTable2(newCfg);
    });

    document.getElementById("removeActivityRowBtn2").addEventListener("click", () => {
      const tbody = document.getElementById("activityConfigTable2").querySelector("tbody");
      if (tbody.rows.length > 0) {
        tbody.removeChild(tbody.lastElementChild);
        activityConfigs2.pop();
      }
    });

    // ====== GENERATE DEPENDENCY TABLE ======
    function generateDependencyTable2() {
      dependencyConfigs2 = [];
      const tbody = document.getElementById("dependencyTable2").querySelector("tbody");
      tbody.innerHTML = "";

      // For each activity, read its "dependencies" array
      networkActivities2.forEach(act => {
        if (Array.isArray(act.dependencies) && act.dependencies.length > 0) {
          act.dependencies.forEach(dep => {
            const depConfig = {
              activity: act.name,
              predecessor: dep.predecessor,
              depType: dep.type || "FS",
              lag: dep.lag || 0
            };
            dependencyConfigs2.push(depConfig);
            addDependencyRowToTable2(depConfig);
          });
        }
      });
      console.log("Dependency table 2 done:", dependencyConfigs2);
    }

    function addDependencyRowToTable2(depConfig) {
      const tbody = document.getElementById("dependencyTable2").querySelector("tbody");
      const tr = document.createElement("tr");

      // Activity cell
      let tdAct = document.createElement("td");
      let inputAct = document.createElement("input");
      inputAct.type = "text";
      inputAct.value = depConfig.activity || "";
      inputAct.addEventListener("input", e => {
        depConfig.activity = e.target.value.trim();
      });
      tdAct.appendChild(inputAct);
      tr.appendChild(tdAct);

      // Predecessor
      let tdPred = document.createElement("td");
      let inputPred = document.createElement("input");
      inputPred.type = "text";
      inputPred.value = depConfig.predecessor || "";
      inputPred.addEventListener("input", e => {
        depConfig.predecessor = e.target.value.trim();
      });
      tdPred.appendChild(inputPred);
      tr.appendChild(tdPred);

      // Dependency Type
      let tdDepType = document.createElement("td");
      let selectDep = document.createElement("select");
      dependencyTypes2.forEach(dt => {
        const option = document.createElement("option");
        option.value = dt.value;
        option.textContent = dt.label;
        if (dt.value === depConfig.depType) option.selected = true;
        selectDep.appendChild(option);
      });
      selectDep.addEventListener("change", e => {
        depConfig.depType = e.target.value;
      });
      tdDepType.appendChild(selectDep);
      tr.appendChild(tdDepType);

      // Lead/Lag
      let tdLag = document.createElement("td");
      let inputLag = document.createElement("input");
      inputLag.type = "number";
      inputLag.value = depConfig.lag || 0;
      inputLag.addEventListener("input", e => {
        depConfig.lag = parseFloat(e.target.value) || 0;
      });
      tdLag.appendChild(inputLag);
      tr.appendChild(tdLag);

      tbody.appendChild(tr);
    }

    document.getElementById("addDependencyRowBtn2").addEventListener("click", () => {
      const newDep = { activity: "", predecessor: "", depType: "FS", lag: 0 };
      dependencyConfigs2.push(newDep);
      addDependencyRowToTable2(newDep);
    });

    document.getElementById("removeDependencyRowBtn2").addEventListener("click", () => {
      const tbody = document.getElementById("dependencyTable2").querySelector("tbody");
      if (tbody.rows.length > 0) {
        tbody.removeChild(tbody.lastElementChild);
        dependencyConfigs2.pop();
      }
    });

    // ====== RUN SIMULATION ======
    document.getElementById("runSimBtn2").addEventListener("click", () => {
      buildNetworkActivitiesFromTables2();

      const nTrials = parseInt(document.getElementById("numTrials2").value) || 1000;
      simulatedDurations2 = [];

      console.log("Starting simulation (Tool 2) with", nTrials, "trials.");

      // Prepare distribution config for each activity
      let distMap = {};
      activityConfigs2.forEach(cfg => {
        distMap[cfg.name] = cfg;
      });

      // Build concurrency map: concurrencyMap[actName] = array of {predecessor, type, lag}
      let concurrencyMap = {};
      networkActivities2.forEach(act => {
        concurrencyMap[act.name] = [];
      });
      dependencyConfigs2.forEach(dep => {
        concurrencyMap[dep.activity].push({
          predecessor: dep.predecessor,
          type: dep.depType,
          lag: dep.lag
        });
      });

      // Perform Monte Carlo
      for (let i = 0; i < nTrials; i++) {
        // Sample durations
        let sampledDurations = {};
        networkActivities2.forEach(act => {
          let c = distMap[act.name];
          if (!c) {
            sampledDurations[act.name] = act.duration;
          } else {
            sampledDurations[act.name] = sampleDistribution(c.dist, c.params, c.base);
          }
        });
        // Now run the older iterative approach:
        let finishTimes = computeScheduleIterative(sampledDurations, concurrencyMap);
        let projDuration = Math.max(...Object.values(finishTimes));
        simulatedDurations2.push(projDuration);
      }

      simulatedDurations2.sort((a, b) => a - b);
      console.log("Simulation complete (Tool 2). Durations:", simulatedDurations2);

      displayStats(simulatedDurations2);
      drawHistogram(simulatedDurations2);

      document.getElementById("resultsArea2").style.display = "block";
      document.getElementById("sliderContainer2").style.display = "block";
      updatePercentile2();
    });

    // Create a local networkActivities2 array from the config tables
    function buildNetworkActivitiesFromTables2() {
      networkActivities2 = [];
      activityConfigs2.forEach(cfg => {
        let actObj = {
          name: cfg.name || "Unnamed",
          duration: cfg.base || 0,
          dependencies: []
        };
        // Preserve suggestedRisk from Tab1 JSON
        if (cfg.suggestedRisk) {
          actObj.suggestedRisk = cfg.suggestedRisk;
        }
        networkActivities2.push(actObj);
      });
      dependencyConfigs2.forEach(dep => {
        let act = networkActivities2.find(a => a.name === dep.activity);
        if (!act) {
          act = { name: dep.activity || "Unnamed", duration: 0, dependencies: [] };
          networkActivities2.push(act);
        }
        act.dependencies.push({
          predecessor: dep.predecessor,
          type: dep.depType,
          lag: dep.lag
        });
      });
      console.log("Built networkActivities2:", networkActivities2);
    }

    // ====== Older Iterative Approach to Scheduling ======
    // This avoids BFS to handle SS/FF with leads/lags more reliably
    function computeScheduleIterative(sampledDurations, concurrencyMap) {
      let S = {}, F = {};

      let allNames = Object.keys(concurrencyMap);

      // inDegree only for identifying tasks with no preds
      let inDegree = {};
      allNames.forEach(n => { inDegree[n] = 0; });
      allNames.forEach(actName => {
        concurrencyMap[actName].forEach(dep => {
          inDegree[actName] += 1;
        });
      });

      // Initialize S/F for tasks with inDegree=0
      allNames.forEach(n => {
        if (inDegree[n] === 0) {
          S[n] = 0;
          F[n] = sampledDurations[n] || 0;
        }
      });

      // We'll keep scanning until no tasks remain "unresolved"
      let unresolved = new Set(allNames);
      for (let n in S) {
        unresolved.delete(n);
      }

      // Repeatedly scan tasks until all are resolved or no progress
      while (unresolved.size > 0) {
        let progress = false;

        allNames.forEach(actName => {
          if (!unresolved.has(actName)) {
            return; // already solved
          }

          let deps = concurrencyMap[actName];
          let ready = true;
          let startConstraint = 0;
          let myDur = sampledDurations[actName] || 0;

          // Check each dependency
          deps.forEach(d => {
            let pred = d.predecessor;
            // If predecessor isn't resolved, can't schedule this yet
            if (!(pred in S) || !(pred in F)) {
              ready = false;
              return;
            }
            let predStart = S[pred];
            let predFinish = F[pred];
            let candidate = 0;

            switch (d.type) {
              case "FS":
                candidate = predFinish + d.lag;
                break;
              case "SS":
                candidate = predStart + d.lag;
                break;
              case "FF":
                candidate = predFinish + d.lag - myDur;
                break;
              case "SF":
                candidate = predStart + d.lag - myDur;
                break;
            }
            // clamp negative start times
            if (candidate < 0) {
              candidate = 0;
            }
            if (candidate > startConstraint) {
              startConstraint = candidate;
            }
          });

          if (ready) {
            S[actName] = startConstraint;
            F[actName] = startConstraint + myDur;
            unresolved.delete(actName);
            progress = true;
          }
        });

        if (!progress) {
          alert("Cycle detected or unresolved lead/lag in network!");
          break;
        }
      }

      return F; // finish times
    }

    // ====== Distribution Samplers (unchanged) ======
    function sampleDistribution(distType, parts, base) {
      switch (distType) {
        case "triangular":
          if (parts.length < 3) return base;
          return sampleTriangular(parts[0], parts[1], parts[2]);
        case "normal":
          if (parts.length < 2) return base;
          return sampleNormal(parts[0], parts[1]);
        case "uniform":
          if (parts.length < 2) return base;
          return sampleUniform(parts[0], parts[1]);
        case "pert":
          if (parts.length < 3) return base;
          return samplePERT(parts[0], parts[1], parts[2]);
        case "exponential":
          if (parts.length < 1) return base;
          return sampleExponential(parts[0]);
        case "lognormal":
          if (parts.length < 2) return base;
          return sampleLognormal(parts[0], parts[1]);
        case "weibull":
          if (parts.length < 2) return base;
          return sampleWeibull(parts[0], parts[1]);
        case "gamma":
          if (parts.length < 2) return base;
          return sampleGammaDistribution(parts[0], parts[1]);
        case "poisson":
          if (parts.length < 1) return base;
          return samplePoisson(parts[0]);
        case "binomial":
          if (parts.length < 2) return base;
          return sampleBinomial(parts[0], parts[1]);
        default:
          return base;
      }
    }

    function sampleTriangular(min, mode, max) {
      const u = Math.random();
      const c = (mode - min) / (max - min);
      return (u < c)
        ? min + Math.sqrt(u * (max - min) * (mode - min))
        : max - Math.sqrt((1 - u) * (max - min) * (max - mode));
    }

    function sampleNormal(mean, stdDev) {
      let u1 = 0, u2 = 0;
      while (u1 === 0) u1 = Math.random();
      while (u2 === 0) u2 = Math.random();
      const z = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
      return mean + z * stdDev;
    }

    function sampleUniform(min, max) {
      return min + (max - min) * Math.random();
    }

    function samplePERT(optimistic, mostLikely, pessimistic) {
      if (mostLikely < optimistic) mostLikely = optimistic;
      if (mostLikely > pessimistic) mostLikely = pessimistic;
      const range = pessimistic - optimistic;
      if (range <= 0) return optimistic;
      const modeRel = (mostLikely - optimistic) / range;
      const alpha = 1 + 4 * modeRel;
      const beta  = 1 + 4 * (1 - modeRel);
      const z = sampleBeta(alpha, beta);
      return optimistic + z * range;
    }

    function sampleExponential(lambda) {
      const u = Math.random();
      return -Math.log(u) / lambda;
    }

    function sampleLognormal(mu, sigma) {
      const n = sampleNormal(mu, sigma);
      return Math.exp(n);
    }

    function sampleWeibull(shape, scale) {
      const u = Math.random();
      return scale * Math.pow(-Math.log(1 - u), 1 / shape);
    }

    function sampleGammaDistribution(shape, scale) {
      return gammaSample(shape) * scale;
    }

    function samplePoisson(lambda) {
      const L = Math.exp(-lambda);
      let k = 0, p = 1;
      do {
        k++;
        p *= Math.random();
      } while (p > L);
      return k - 1;
    }

    function sampleBinomial(n, p) {
      let successes = 0;
      for (let i = 0; i < n; i++) {
        if (Math.random() < p) successes++;
      }
      return successes;
    }

    function sampleBeta(alpha, beta) {
      const x = gammaSample(alpha), y = gammaSample(beta);
      return x / (x + y);
    }

    function gammaSample(k) {
      if (k < 1) {
        return gammaSample(1 + k) * Math.pow(Math.random(), 1 / k);
      }
      const d = k - 1/3, c = 1 / Math.sqrt(9*d);
      while (true) {
        let x, v;
        do {
          const u1 = Math.random(), u2 = Math.random();
          const z = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
          x = z;
          v = 1 + c*x;
        } while (v <= 0);
        v = v * v * v;
        const u3 = Math.random();
        if (u3 < 1 - 0.0331 * Math.pow(x, 4)) {
          return d * v;
        }
        if (Math.log(u3) < 0.5 * x*x + d*(1 - v + Math.log(v))) {
          return d * v;
        }
      }
    }

    // ====== STATS & HISTOGRAM ======
    function displayStats(dataArray) {
      const n = dataArray.length;
      if (n < 1) return;
      const minVal = dataArray[0], maxVal = dataArray[n - 1];
      let sum = dataArray.reduce((acc, val) => acc + val, 0);
      const mean = sum / n;
      let variance = dataArray.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / n;
      const stdDev = Math.sqrt(variance);

      document.getElementById("statsOutput2").innerHTML = `
        <div class="stat-line"><span class="stat-label">Trials:</span>${n}</div>
        <div class="stat-line"><span class="stat-label">Min Duration:</span>${minVal.toFixed(2)}</div>
        <div class="stat-line"><span class="stat-label">Max Duration:</span>${maxVal.toFixed(2)}</div>
        <div class="stat-line"><span class="stat-label">Mean Duration:</span>${mean.toFixed(2)}</div>
        <div class="stat-line"><span class="stat-label">Std Dev:</span>${stdDev.toFixed(2)}</div>
      `;
    }

    function drawHistogram(dataArray, highlightVal = NaN) {
      const histCanvas2 = document.getElementById("histogramCanvas2");
      const histCtx2 = histCanvas2.getContext("2d");
      histCtx2.clearRect(0, 0, histCanvas2.width, histCanvas2.height);

      const canvasWidth = histCanvas2.width, canvasHeight = histCanvas2.height;
      const marginLeft = 50, marginRight = 20, marginTop = 20, marginBottom = 50;
      const plotWidth = canvasWidth - marginLeft - marginRight;
      const plotHeight = canvasHeight - marginTop - marginBottom;

      const n = dataArray.length;
      if (n < 2) return;

      const minVal = dataArray[0], maxVal = dataArray[n-1];
      const range = maxVal - minVal;
      const binCount = 30;
      const binSize = range / binCount;
      const freq = new Array(binCount).fill(0);

      dataArray.forEach(val => {
        let idx = Math.floor((val - minVal) / binSize);
        if (idx < 0) idx = 0;
        if (idx >= binCount) idx = binCount - 1;
        freq[idx]++;
      });

      const maxFreq = Math.max(...freq);

      // Axes
      histCtx2.strokeStyle = "#333";
      histCtx2.lineWidth = 1;
      // X axis
      histCtx2.beginPath();
      histCtx2.moveTo(marginLeft, marginTop + plotHeight);
      histCtx2.lineTo(marginLeft + plotWidth, marginTop + plotHeight);
      histCtx2.stroke();

      // Y axis
      histCtx2.beginPath();
      histCtx2.moveTo(marginLeft, marginTop);
      histCtx2.lineTo(marginLeft, marginTop + plotHeight);
      histCtx2.stroke();

      // Labels
      histCtx2.font = "11px sans-serif";
      histCtx2.fillStyle = "#000";
      histCtx2.textAlign = "center";
      histCtx2.fillText("Project Duration", marginLeft + plotWidth / 2, canvasHeight - 10);

      // Y label
      histCtx2.save();
      histCtx2.translate(15, marginTop + plotHeight / 2);
      histCtx2.rotate(-Math.PI / 2);
      histCtx2.fillText("Frequency", 0, 0);
      histCtx2.restore();

      // Draw bars
      histCtx2.fillStyle = "#0077cc";
      const barWidth = plotWidth / binCount;
      for (let i = 0; i < binCount; i++) {
        const barHeight = (freq[i] / maxFreq) * plotHeight;
        const x = marginLeft + i * barWidth;
        const y = marginTop + (plotHeight - barHeight);
        histCtx2.fillRect(x, y, barWidth - 1, barHeight);
      }

      // X min/max
      histCtx2.textAlign = "left";
      histCtx2.fillText(minVal.toFixed(2), marginLeft, marginTop + plotHeight + 12);
      histCtx2.textAlign = "right";
      histCtx2.fillText(maxVal.toFixed(2), marginLeft + plotWidth, marginTop + plotHeight + 12);

      // Highlight line
      if (!isNaN(highlightVal)) {
        const xPos = marginLeft + ((highlightVal - minVal) / range) * plotWidth;
        if (xPos >= marginLeft && xPos <= marginLeft + plotWidth) {
          histCtx2.strokeStyle = "red";
          histCtx2.beginPath();
          histCtx2.moveTo(xPos, marginTop);
          histCtx2.lineTo(xPos, marginTop + plotHeight);
          histCtx2.stroke();
        }
      }
    }

    // ====== HANDLE PERCENTILE ======
    document.getElementById("percentileSlider2").addEventListener("input", updatePercentile2);

    function updatePercentile2() {
      const pct = parseInt(document.getElementById("percentileSlider2").value);
      document.getElementById("percentileValue2").textContent = pct;

      let idx = Math.floor((pct / 100) * simulatedDurations2.length);
      if (idx >= simulatedDurations2.length) idx = simulatedDurations2.length - 1;
      if (idx < 0) idx = 0;

      const val = simulatedDurations2[idx];
      document.getElementById("valAtPercentile2").textContent = val.toFixed(2);

      drawHistogram(simulatedDurations2, val);
      document.getElementById("percentileText2").textContent =
        `At the ${pct}% percentile, there's a ${pct}% chance project duration ≤ ${val.toFixed(2)}.`;
      document.getElementById("sliderContainer2").style.display = "block";
    }

    // ====== Apply ±X% or PERT Adjustments ======
    document.getElementById("apply10Btn2").addEventListener("click", () => { applyAdjustment2(0.10); });
    document.getElementById("apply20Btn2").addEventListener("click", () => { applyAdjustment2(0.20); });

    function applyAdjustment2(percentage) {
      activityConfigs2.forEach(cfg => {
        let base = cfg.base;
        cfg.dist = "uniform";
        let newMin = base * (1 - percentage);
        let newMax = base * (1 + percentage);
        cfg.params = [newMin, newMax];
      });
      updateActivityTableUI();
      alert(`Applied ±${percentage*100}% adjustment to all activities.`);
    }

    document.getElementById("applyPert10Btn2").addEventListener("click", () => { applyPertAdjustment2(0.10); });
    document.getElementById("applyPert20Btn2").addEventListener("click", () => { applyPertAdjustment2(0.20); });

    function applyPertAdjustment2(percentage) {
      activityConfigs2.forEach(cfg => {
        let base = cfg.base;
        cfg.dist = "pert";
        cfg.params = [base * (1 - percentage), base, base * (1 + percentage)];
      });
      updateActivityTableUI();
      alert(`Applied ±${percentage*100}% PERT adjustment to all activities.`);
    }

    // Helper to refresh the distribution type + param fields in the activity table
    function updateActivityTableUI() {
      const rows = document.getElementById("activityConfigTable2").querySelector("tbody").rows;
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        let cfg = activityConfigs2[i];
        row.cells[2].querySelector("select").value = cfg.dist;
        row.cells[3].querySelector("input").value = cfg.params.join(",");
      }
    }

    // ====== Risk Report Buttons ======
    document.getElementById("generateProjectRiskReportBtn2").addEventListener("click", generateProjectRiskReport2);
    document.getElementById("generateActivityRiskReportsBtn2").addEventListener("click", generateActivityRiskReports2);

    function generateProjectRiskReport2() {
      const sliderVal = parseInt(document.getElementById("percentileSlider2").value);
      let idx = Math.floor((sliderVal / 100) * simulatedDurations2.length);
      if (idx >= simulatedDurations2.length) idx = simulatedDurations2.length - 1;
      if (idx < 0) idx = 0;

      const duration = simulatedDurations2[idx];
      const riskProb = 100 - sliderVal;
      const riskName = "Project exceeding " + duration.toFixed(2);
      const impact = 10;
      addRiskToTab3(riskName, riskProb, impact);
      alert("Project risk report generated and added to Risk Assessment (Tab 3).");
    }

    function generateActivityRiskReports2() {
      const sliderVal = parseInt(document.getElementById("percentileSlider2").value);
      let idx = Math.floor((sliderVal / 100) * simulatedDurations2.length);
      if (idx >= simulatedDurations2.length) idx = simulatedDurations2.length - 1;
      if (idx < 0) idx = 0;

      const duration = simulatedDurations2[idx];
      const riskProb = 100 - sliderVal;

      // For each activity, use suggestedRisk from JSON if available
      networkActivities2.forEach(act => {
        const riskName = "Delay in " + act.name + " exceeding " + duration.toFixed(2);
        const impact = act.suggestedRisk ? act.suggestedRisk : 10;
        addRiskToTab3(riskName, riskProb, impact);
      });
      alert("Risk reports for each activity generated and added to Risk Assessment (Tab 3).");
    }

    // This function presumably exists in your global code to push risks to Tab 3
    function addRiskToTab3(riskName, probability, impact) {
      const riskTableBody = document.querySelector("#riskTable tbody");
      if (!riskTableBody) {
        console.error("Risk table not found!");
        return;
      }
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input type="text" value="${riskName}" /></td>
        <td><input type="number" min="0" max="100" value="${probability}" /></td>
        <td><input type="number" min="1" max="10" value="${impact}" /></td>
        <td>
          <button class="calc-btn" onclick="window.open('../monte-carlo/index.html','_blank')">MC Sequential</button>
          <button class="calc-btn" onclick="window.open('../advanced-scheduling/index.html','_blank')">MC Parallel</button>
        </td>
      `;
      riskTableBody.appendChild(tr);
    }
  </script>
</div>
<!-- END REPLACEMENT CODE FOR TAB 2 -->

      

  <!-- Tab 3: Resources Tool -->
  <div id="tab3" class="tab-content">
    <script>
      // ***** FIX #2b: Auto-load JSON from localStorage on Tab 3
      window.addEventListener("load", () => {
        const tab1JSON = localStorage.getItem("networkJSON");
        if (tab1JSON) {
          document.getElementById("jsonInput").value = tab1JSON;
        }
      });
    </script>

    <div class="container">
      <button id="backButtonResources" onclick="window.location.href='https://projectmanagerhelper.com'">Back to Main Page</button>
      <h1>Tasks &amp; Resources with Critical Path Gantt</h1>
      <p>
        Paste advanced JSON from Tab 1 here, then load.<br>
        - For <strong>Work</strong> resources, the assignment field = “%” (like 100).<br>
        - For <strong>Material/Cost</strong>, the assignment field = “units” (like 6).<br>
        <strong>Zoom</strong> the Gantt with the slider, and scroll horizontally if needed.<br>
        <strong>Critical path</strong> tasks (float≈0) are highlighted red.
      </p>
      <textarea id="jsonInput" placeholder="Paste JSON from Tab 1 here..."></textarea>
      <button id="loadJsonBtn">Load JSON</button>
    </div>

    <div class="container">
      <h2>Tasks</h2>
      <button id="addTaskBtn">Add Task</button>
      <table id="tasksTable">
        <thead>
          <tr>
            <th>Task Name</th>
            <th>Dependencies<br>(predecessor|type|lag)</th>
            <th>Duration (days)</th>
            <th>Assignments</th>
            <th>Cost</th>
          </tr>
        </thead>
        <tbody>
          <!-- Populated dynamically -->
        </tbody>
      </table>
    </div>

    <div class="container">
      <h2>Resources</h2>
      <button id="addResourceBtn">Add Resource</button>
      <table id="resourcesTable">
        <thead>
          <tr>
            <th>Resource Name</th>
            <th>Type</th>
            <th>Material</th>
            <th>Initials</th>
            <th>Group</th>
            <th>Max Units (%)</th>
            <th>Std. Rate ($/hr or $/unit)</th>
            <th>Ovt. Rate ($/hr)</th>
            <th>Cost/Use</th>
            <th>Accrue</th>
            <th>Base</th>
          </tr>
        </thead>
        <tbody>
          <!-- Populated dynamically -->
        </tbody>
      </table>
    </div>

    <div class="container">
      <button id="checkOverallocationBtn">Compute Overallocation</button>
      <div id="overallocationOutput"></div>
      <div style="margin-top:1em;">
        <label for="zoomRange">Zoom (px/day):</label>
        <input type="range" id="zoomRange" min="10" max="200" value="50" style="width:200px;">
        <span id="zoomValue">50</span>
      </div>
      <button id="generateGanttBtn">Generate Gantt Chart</button>
      <div id="ganttContainer">
        <svg id="ganttChart" height="500"></svg>
      </div>
      <!-- Resources Risk Insights -->
      <button id="generateResourceRiskBtn" style="margin-top:1em;">Generate Resource Risk Insights</button>
      <div id="resourceRiskOutput"></div>
      <!-- Risk JSON Output Container with copy-to-clipboard -->
      <div id="riskJsonOutputContainer">
        <label for="riskJsonOutput"><strong>Risk JSON Output (for Risk Register):</strong></label>
        <textarea id="riskJsonOutput" readonly></textarea>
        <br>
        <button id="copyRiskJsonBtn">Copy to Clipboard</button>
      </div>
    </div>

    <!-- Modal for double-click editing in Resources tool -->
    <div id="modalOverlay"></div>
    <div id="editModal">
      <h3>Edit Task</h3>
      <div>
        <label>Task Name:</label><br>
        <input type="text" id="modalTaskName">
      </div>
      <div>
        <label>Duration (days):</label><br>
        <input type="number" id="modalTaskDuration">
      </div>
      <div>
        <label>Dependencies:</label><br>
        <textarea id="modalDependencies" rows="3" style="width:95%;"></textarea>
        <small>Format: predecessor|type|lag, one per line (e.g. <code>B|SS|2</code>).</small>
      </div>
      <div>
        <label>Assignments (Resource=Number):</label><br>
        <textarea id="modalAssignments" rows="3" style="width:95%;"></textarea>
        <small>For Work resources, the number is “%.” For Material/Cost, the number is “units.”</small>
      </div>
      <div style="margin-top:10px;">
        <button id="modalSaveBtn">Save</button>
        <button id="modalCancelBtn">Cancel</button>
      </div>
    </div>

    <script>
      /* Resources Tool JS (from your previous resources tool code) */
      let tasksData = [];      // Each task: { name, dependencies: [{predecessor, type, lag}], duration, assignments: [{ resourceName, value }], cost, float }
      let resourcesData = [];  // Each resource: { name, type, material, initials, group, maxUnits, stdRate, ovtRate, costUse, accrue, base }
      let ganttScale = 50;     // px per day (zoom)
      const hoursPerDayMap = { "Standard":8, "24 Hours":24, "Night Shift":8 };

      document.getElementById("loadJsonBtn").addEventListener("click", () => {
        const text = document.getElementById("jsonInput").value.trim();
        if (!text) return;
        let arr;
        try {
          arr = JSON.parse(text);
        } catch(e) {
          alert("Invalid JSON.");
          return;
        }
        if (!Array.isArray(arr)) {
          alert("JSON must be an array.");
          return;
        }
        tasksData = arr.map(item => ({
          name: item.name || "Unnamed",
          dependencies: (item.dependencies||[]).map(d=>({
            predecessor: d.predecessor || "",
            type: d.type || "FS",
            lag: d.lag || 0
          })),
          duration: item.duration || 0,
          assignments: [],
          cost: 0
        }));
        renderTasksTable();
      });

      document.getElementById("addTaskBtn").addEventListener("click", () => {
        tasksData.push({ name:"New Task", dependencies: [], duration: 5, assignments: [], cost: 0 });
        renderTasksTable();
      });

      function renderTasksTable() {
        const tbody = document.getElementById("tasksTable").querySelector("tbody");
        tbody.innerHTML = "";
        tasksData.forEach((task, index) => {
          const tr = document.createElement("tr");

          let tdName = document.createElement("td");
          let inputName = document.createElement("input");
          inputName.type = "text";
          inputName.value = task.name;
          inputName.addEventListener("blur", e => {
            task.name = e.target.value.trim();
          });
          tdName.appendChild(inputName);
          tr.appendChild(tdName);

          let tdDeps = document.createElement("td");
          let depStr = task.dependencies.map(d => `${d.predecessor}|${d.type}|${d.lag}`).join("\n");
          let txtDeps = document.createElement("textarea");
          txtDeps.rows = 1;
          txtDeps.classList.add("small-textarea");
          txtDeps.value = depStr;
          txtDeps.addEventListener("blur", e => {
            let lines = e.target.value.split("\n").map(s=>s.trim()).filter(Boolean);
            let newDeps = [];
            lines.forEach(line => {
              let parts = line.split("|").map(x=>x.trim());
              if (parts.length >= 1) {
                newDeps.push({ predecessor: parts[0], type: parts[1] || "FS", lag: parseFloat(parts[2]) || 0 });
              }
            });
            task.dependencies = newDeps;
          });
          tdDeps.appendChild(txtDeps);
          tr.appendChild(tdDeps);

          let tdDur = document.createElement("td");
          let inputDur = document.createElement("input");
          inputDur.type = "number";
          inputDur.value = task.duration;
          inputDur.addEventListener("blur", e => {
            task.duration = parseFloat(e.target.value)||0;
            recalcTaskCost(index);
          });
          tdDur.appendChild(inputDur);
          tr.appendChild(tdDur);

          let tdAssign = document.createElement("td");
          let container = document.createElement("div");
          container.className = "assignments-container";
          task.assignments.forEach((assn, aIdx) => {
            container.appendChild(createAssignmentRow(task, index, aIdx));
          });
          let addBtn = document.createElement("button");
          addBtn.textContent = "+ Resource";
          addBtn.style.marginTop = "4px";
          addBtn.addEventListener("click", () => {
            task.assignments.push({ resourceName:"", value:100 });
            renderTasksTable();
          });
          container.appendChild(addBtn);
          tdAssign.appendChild(container);
          tr.appendChild(tdAssign);

          let tdCost = document.createElement("td");
          tdCost.textContent = `$${task.cost.toFixed(2)}`;
          tr.appendChild(tdCost);

          tbody.appendChild(tr);
        });
      }

      function createAssignmentRow(task, taskIndex, assignmentIndex) {
        let assn = task.assignments[assignmentIndex];
        let rowDiv = document.createElement("div");
        rowDiv.className = "assignment-row";

        let selRes = document.createElement("select");
        let blankOpt = document.createElement("option");
        blankOpt.value = ""; blankOpt.textContent = "(Select Resource)";
        selRes.appendChild(blankOpt);

        resourcesData.forEach(r => {
          let opt = document.createElement("option");
          opt.value = r.name; opt.textContent = r.name;
          if (r.name === assn.resourceName) opt.selected = true;
          selRes.appendChild(opt);
        });
        selRes.addEventListener("blur", e => {
          assn.resourceName = e.target.value;
          recalcTaskCost(taskIndex);
        });
        rowDiv.appendChild(selRes);

        let inputVal = document.createElement("input");
        inputVal.type = "number";
        inputVal.value = assn.value || 100;
        inputVal.min = 0;
        inputVal.addEventListener("blur", e => {
          assn.value = parseFloat(e.target.value)||0;
          recalcTaskCost(taskIndex);
        });
        rowDiv.appendChild(inputVal);

        let removeBtn = document.createElement("button");
        removeBtn.textContent = "X";
        removeBtn.style.backgroundColor = "#f44336";
        removeBtn.style.marginLeft = "8px";
        removeBtn.addEventListener("click", () => {
          task.assignments.splice(assignmentIndex, 1);
          renderTasksTable();
        });
        rowDiv.appendChild(removeBtn);

        return rowDiv;
      }

      document.getElementById("addResourceBtn").addEventListener("click", () => {
        resourcesData.push({
          name:"New Resource",
          type:"Work",
          material:"",
          initials:"",
          group:"",
          maxUnits:100,
          stdRate:0,
          ovtRate:0,
          costUse:0,
          accrue:"Prorated",
          base:"Standard"
        });
        renderResourcesTable();
      });

      function renderResourcesTable() {
        const tbody = document.getElementById("resourcesTable").querySelector("tbody");
        tbody.innerHTML = "";
        resourcesData.forEach((res, index) => {
          let tr = document.createElement("tr");

          let tdName = document.createElement("td");
          let inpName = document.createElement("input");
          inpName.type = "text";
          inpName.value = res.name;
          inpName.addEventListener("blur", e => {
            res.name = e.target.value.trim();
            renderTasksTable();
          });
          tdName.appendChild(inpName);
          tr.appendChild(tdName);

          let tdType = document.createElement("td");
          let selType = document.createElement("select");
          ["Work","Material","Cost"].forEach(t => {
            let opt = document.createElement("option");
            opt.value = t; opt.textContent = t;
            if (t === res.type) opt.selected = true;
            selType.appendChild(opt);
          });
          selType.addEventListener("blur", e => {
            res.type = e.target.value;
          });
          tdType.appendChild(selType);
          tr.appendChild(tdType);

          let tdMat = document.createElement("td");
          let inpMat = document.createElement("input");
          inpMat.type = "text";
          inpMat.value = res.material;
          inpMat.addEventListener("blur", e => {
            res.material = e.target.value.trim();
          });
          tdMat.appendChild(inpMat);
          tr.appendChild(tdMat);

          let tdInit = document.createElement("td");
          let inpInit = document.createElement("input");
          inpInit.type = "text";
          inpInit.value = res.initials;
          inpInit.addEventListener("blur", e => {
            res.initials = e.target.value.trim();
          });
          tdInit.appendChild(inpInit);
          tr.appendChild(tdInit);

          let tdGrp = document.createElement("td");
          let inpGrp = document.createElement("input");
          inpGrp.type = "text";
          inpGrp.value = res.group;
          inpGrp.addEventListener("blur", e => {
            res.group = e.target.value.trim();
          });
          tdGrp.appendChild(inpGrp);
          tr.appendChild(tdGrp);

          let tdMax = document.createElement("td");
          let inpMax = document.createElement("input");
          inpMax.type = "number";
          inpMax.value = res.maxUnits;
          inpMax.addEventListener("blur", e => {
            res.maxUnits = parseFloat(e.target.value)||100;
          });
          tdMax.appendChild(inpMax);
          tr.appendChild(tdMax);

          let tdStd = document.createElement("td");
          let inpStd = document.createElement("input");
          inpStd.type = "number";
          inpStd.value = res.stdRate;
          inpStd.addEventListener("blur", e => {
            res.stdRate = parseFloat(e.target.value)||0;
          });
          tdStd.appendChild(inpStd);
          tr.appendChild(tdStd);

          let tdOvt = document.createElement("td");
          let inpOvt = document.createElement("input");
          inpOvt.type = "number";
          inpOvt.value = res.ovtRate;
          inpOvt.addEventListener("blur", e => {
            res.ovtRate = parseFloat(e.target.value)||0;
          });
          tdOvt.appendChild(inpOvt);
          tr.appendChild(tdOvt);

          let tdCU = document.createElement("td");
          let inpCU = document.createElement("input");
          inpCU.type = "number";
          inpCU.value = res.costUse;
          inpCU.addEventListener("blur", e => {
            res.costUse = parseFloat(e.target.value)||0;
          });
          tdCU.appendChild(inpCU);
          tr.appendChild(tdCU);

          let tdAcc = document.createElement("td");
          let selAcc = document.createElement("select");
          ["Start","Prorated","End"].forEach(a => {
            let opt = document.createElement("option");
            opt.value = a; opt.textContent = a;
            if (a === res.accrue) opt.selected = true;
            selAcc.appendChild(opt);
          });
          selAcc.addEventListener("blur", e => {
            res.accrue = e.target.value;
          });
          tdAcc.appendChild(selAcc);
          tr.appendChild(tdAcc);

          let tdBase = document.createElement("td");
          let selBase = document.createElement("select");
          ["Standard","24 Hours","Night Shift"].forEach(b => {
            let opt = document.createElement("option");
            opt.value = b; opt.textContent = b;
            if (b === res.base) opt.selected = true;
            selBase.appendChild(opt);
          });
          selBase.addEventListener("blur", e => {
            res.base = e.target.value;
          });
          tdBase.appendChild(selBase);
          tr.appendChild(tdBase);

          tbody.appendChild(tr);
        });
      }

      renderTasksTable();
      renderResourcesTable();

      function recalcTaskCost(taskIndex) {
        let task = tasksData[taskIndex];
        let totalCost = 0;
        task.assignments.forEach(a => {
          let r = resourcesData.find(rr => rr.name === a.resourceName);
          if (!r) return;
          let val = a.value || 0;
          let hoursPerDay = hoursPerDayMap[r.base] || 8;
          let resourceCost = 0;
          if (r.type === "Work") {
            let usageFrac = val/100;
            resourceCost = (task.duration * hoursPerDay * r.stdRate * usageFrac) + (r.costUse||0);
          } else if (r.type === "Material") {
            resourceCost = (val * r.stdRate) + (r.costUse||0);
          } else if (r.type === "Cost") {
            resourceCost = (val * (r.costUse||0));
          }
          totalCost += resourceCost;
        });
        task.cost = totalCost;
        renderTasksTable();
      }

      document.getElementById("checkOverallocationBtn").addEventListener("click", computeOverallocation);
      function computeOverallocation() {
        let schedule = computeSchedule();
        let maxFinish = Math.max(...schedule.map(s=>s.finish));
        let dayToResUsage = {};
        for(let d=0; d<=maxFinish; d++){
          dayToResUsage[d] = {};
          resourcesData.forEach(r => { dayToResUsage[d][r.name] = 0; });
        }
        tasksData.forEach((t,i) => {
          let sDay = Math.floor(schedule[i].start);
          let fDay = Math.ceil(schedule[i].finish);
          t.assignments.forEach(a => {
            let rName = a.resourceName;
            if (!rName) return;
            let r = resourcesData.find(rr=>rr.name===rName);
            if (!r) return;
            if(r.type !== "Work") return;
            let val = a.value || 100;
            for(let d = sDay; d < fDay; d++){
              dayToResUsage[d][rName] += val;
            }
          });
        });
        let overallocMsgs = [];
        resourcesData.forEach(r => {
          let mU = r.maxUnits || 100;
          if(r.type !== "Work") return;
          for(let d=0; d<=maxFinish; d++){
            if(dayToResUsage[d][r.name] > mU){
              overallocMsgs.push(`${r.name} overallocated on day ${d} (usage=${dayToResUsage[d][r.name]}%, max=${mU}%)`);
              break;
            }
          }
        });
        let div = document.getElementById("overallocationOutput");
        if(overallocMsgs.length === 0){
          div.style.display = "block";
          div.innerHTML = "<strong>No overallocation found.</strong>";
          div.style.background = "#e6ffe6";
          div.style.border = "1px solid #b3ffb3";
        } else {
          div.style.display = "block";
          div.innerHTML = `<strong class="warn">Overallocation Detected:</strong><br>` + overallocMsgs.join("<br>");
          div.style.background = "#ffe6e6";
          div.style.border = "1px solid #ffa5a5";
        }
      }

      let zoomRange = document.getElementById("zoomRange");
      let zoomValue = document.getElementById("zoomValue");
      zoomRange.addEventListener("input", () => {
        ganttScale = parseInt(zoomRange.value);
        zoomValue.textContent = ganttScale;
      });

      document.getElementById("generateGanttBtn").addEventListener("click", generateGantt);
      function generateGantt() {
        let schedule = computeSchedule();
        let { floatArr } = computeFloat(schedule);
        tasksData.forEach((t,i)=>{ t.float = floatArr[i]; });
        let maxFinish = Math.max(...schedule.map(s=>s.finish));

        const svg = document.getElementById("ganttChart");
        while(svg.firstChild) { svg.removeChild(svg.firstChild); }

        let rowHeight = 20, rowSpacing = 10, leftMargin = 150, topMargin = 20;
        let totalHeight = tasksData.length*(rowHeight+rowSpacing)+topMargin*2+40;
        let totalWidth = (maxFinish+2)*ganttScale+leftMargin+50;
        svg.setAttribute("height", totalHeight);
        svg.setAttribute("width", totalWidth);

        let defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        let marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
        marker.setAttribute("id", "arrowhead");
        marker.setAttribute("viewBox", "0 0 10 10");
        marker.setAttribute("refX", "10");
        marker.setAttribute("refY", "5");
        marker.setAttribute("markerUnits", "strokeWidth");
        marker.setAttribute("markerWidth", "6");
        marker.setAttribute("markerHeight", "6");
        marker.setAttribute("orient", "auto");
        let path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", "M0,0 L10,5 L0,10 Z");
        path.setAttribute("fill", "#555");
        marker.appendChild(path);
        defs.appendChild(marker);
        svg.appendChild(defs);

        tasksData.forEach((t,i)=>{
          let s = schedule[i];
          let x = leftMargin + s.start * ganttScale;
          let y = topMargin + i*(rowHeight+rowSpacing);
          let w = (s.finish - s.start)*ganttScale;
          if(w<0) w=0;
          let bar = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          bar.setAttribute("x", x);
          bar.setAttribute("y", y);
          bar.setAttribute("width", w);
          bar.setAttribute("height", rowHeight);
          bar.setAttribute("class", "task-bar");
          if(t.float < 0.0001) {
            bar.classList.add("critical");
          } else {
            bar.classList.add("noncritical");
          }
          bar.addEventListener("dblclick", ()=>openEditModal(i));
          svg.appendChild(bar);

          let resStr = t.assignments.map(a=>{
            if(!a.resourceName) return "";
            let r = resourcesData.find(rr=>rr.name===a.resourceName);
            if(!r) return "";
            return r.type==="Work" ? `${r.name}(${a.value}%)` : `${r.name}(${a.value})`;
          }).filter(Boolean).join(", ");
          if(resStr) {
            let barText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            barText.setAttribute("x", x+4);
            barText.setAttribute("y", y+rowHeight*0.7);
            barText.setAttribute("class", "bar-text");
            barText.textContent = resStr;
            svg.appendChild(barText);
          }

          let text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", 5);
          text.setAttribute("y", y+rowHeight*0.75);
          text.setAttribute("class", "task-text");
          text.textContent = t.name;
          svg.appendChild(text);
        });

        tasksData.forEach((t,i)=>{
          let s = schedule[i];
          let xStart = leftMargin + s.start * ganttScale;
          let xFinish = leftMargin + s.finish * ganttScale;
          let yMid = topMargin + i*(rowHeight+rowSpacing) + rowHeight/2;
          t.dependencies.forEach(dep=>{
            let predIdx = tasksData.findIndex(tt=>tt.name===dep.predecessor);
            if(predIdx<0) return;
            let sp = schedule[predIdx];
            let pxStart = leftMargin + sp.start * ganttScale;
            let pxFinish = leftMargin + sp.finish * ganttScale;
            let pyMid = topMargin + predIdx*(rowHeight+rowSpacing) + rowHeight/2;
            let fromX, fromY, toX, toY;
            switch(dep.type) {
              case "FS":
                fromX = pxFinish; fromY = pyMid;
                toX = xStart;     toY = yMid;
                break;
              case "SS":
                fromX = pxStart; fromY = pyMid;
                toX = xStart;    toY = yMid;
                break;
              case "FF":
                fromX = pxFinish; fromY = pyMid;
                toX = xFinish;    toY = yMid;
                break;
              case "SF":
                fromX = pxStart;  fromY = pyMid;
                toX = xFinish;    toY = yMid;
                break;
              default:
                fromX = pxFinish; fromY = pyMid;
                toX = xStart;     toY = yMid;
            }
            let pathData = `M${fromX},${fromY} L${fromX},${toY} L${toX},${toY}`;
            let line = document.createElementNS("http://www.w3.org/2000/svg", "path");
            line.setAttribute("d", pathData);
            line.setAttribute("class", "dep-line");
            line.setAttribute("marker-end", "url(#arrowhead)");
            svg.appendChild(line);
          });
        });

        let axisY = topMargin + tasksData.length*(rowHeight+rowSpacing) + 20;
        let axisLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        axisLine.setAttribute("x1", leftMargin);
        axisLine.setAttribute("y1", axisY);
        axisLine.setAttribute("x2", leftMargin+(maxFinish+2)*ganttScale);
        axisLine.setAttribute("y2", axisY);
        axisLine.setAttribute("stroke", "#333");
        svg.appendChild(axisLine);

        for(let d=0; d<=maxFinish+1; d++){
          let tickX = leftMargin + d*ganttScale;
          let tick = document.createElementNS("http://www.w3.org/2000/svg", "line");
          tick.setAttribute("x1", tickX);
          tick.setAttribute("y1", axisY);
          tick.setAttribute("x2", tickX);
          tick.setAttribute("y2", axisY-5);
          tick.setAttribute("stroke", "#333");
          svg.appendChild(tick);

          let lbl = document.createElementNS("http://www.w3.org/2000/svg", "text");
          lbl.setAttribute("x", tickX+2);
          lbl.setAttribute("y", axisY+15);
          lbl.setAttribute("font-size", "12");
          lbl.textContent = d;
          svg.appendChild(lbl);
        }
      }

      let editModal = document.getElementById("editModal");
      let modalOverlay = document.getElementById("modalOverlay");
      let modalTaskName = document.getElementById("modalTaskName");
      let modalTaskDuration = document.getElementById("modalTaskDuration");
      let modalDependencies = document.getElementById("modalDependencies");
      let modalAssignments = document.getElementById("modalAssignments");
      let modalSaveBtn = document.getElementById("modalSaveBtn");
      let modalCancelBtn = document.getElementById("modalCancelBtn");
      let currentEditIndex = -1;

      function openEditModal(taskIndex) {
        currentEditIndex = taskIndex;
        let t = tasksData[taskIndex];
        modalTaskName.value = t.name;
        modalTaskDuration.value = t.duration;
        modalDependencies.value = t.dependencies.map(d=>`${d.predecessor}|${d.type}|${d.lag}`).join("\n");
        modalAssignments.value = t.assignments.map(a=>`${a.resourceName}=${a.value}`).join("\n");
        editModal.style.display = "block";
        modalOverlay.style.display = "block";
      }

      modalCancelBtn.addEventListener("click", closeModal);
      function closeModal() {
        editModal.style.display = "none";
        modalOverlay.style.display = "none";
      }

      modalSaveBtn.addEventListener("click", ()=>{
        if(currentEditIndex < 0) return;
        let t = tasksData[currentEditIndex];
        t.name = modalTaskName.value.trim();
        t.duration = parseFloat(modalTaskDuration.value)||0;

        let lines = modalDependencies.value.split("\n").map(x=>x.trim()).filter(Boolean);
        let newDeps = [];
        lines.forEach(line=>{
          let parts = line.split("|").map(x=>x.trim());
          if(parts.length>=1) {
            newDeps.push({ predecessor: parts[0], type: parts[1]||"FS", lag: parseFloat(parts[2])||0 });
          }
        });
        t.dependencies = newDeps;

        let lines2 = modalAssignments.value.split("\n").map(x=>x.trim()).filter(Boolean);
        let newAssn = [];
        lines2.forEach(line=>{
          let idx = line.indexOf("=");
          if(idx>0) {
            let rName = line.slice(0,idx).trim();
            let val = parseFloat(line.slice(idx+1))||0;
            newAssn.push({ resourceName: rName, value: val });
          }
        });
        t.assignments = newAssn;

        closeModal();
        recalcTaskCost(currentEditIndex);
        renderTasksTable();
      });

      function computeSchedule() {
        let nameToIdx = {};
        tasksData.forEach((t,i)=>{ nameToIdx[t.name] = i; });
        let graph = tasksData.map(()=>[]);
        let inDegree = new Array(tasksData.length).fill(0);
        tasksData.forEach((t,i)=>{
          t.dependencies.forEach(dep=>{
            let p = nameToIdx[dep.predecessor];
            if(p != null) { graph[p].push(i); inDegree[i]++; }
          });
        });
        let schedule = tasksData.map(t=>({ start: 0, finish: t.duration }));
        let queue = [];
        inDegree.forEach((d,i)=>{ if(d===0) queue.push(i); });
        while(queue.length > 0) {
          let cur = queue.shift();
          graph[cur].forEach(succ=>{
            let depObj = tasksData[succ].dependencies.find(d=>d.predecessor === tasksData[cur].name);
            if(!depObj) return;
            let cStart = schedule[cur].start, cFinish = schedule[cur].finish;
            let lag = depObj.lag || 0;
            let candidate = 0;
            switch(depObj.type) {
              case "FS": candidate = cFinish + lag; break;
              case "SS": candidate = cStart + lag; break;
              case "FF": candidate = (cFinish + lag) - tasksData[succ].duration; break;
              case "SF": candidate = (cStart + lag) - tasksData[succ].duration; break;
            }
            if(candidate < 0) candidate = 0;
            if(candidate > schedule[succ].start) {
              schedule[succ].start = candidate;
              schedule[succ].finish = candidate + tasksData[succ].duration;
            }
            inDegree[succ]--;
            if(inDegree[succ] === 0) queue.push(succ);
          });
        }
        return schedule;
      }

      function computeFloat(schedule) {
        let endTime = Math.max(...schedule.map(s=>s.finish));
        let n = tasksData.length;
        let latestStart = new Array(n).fill(endTime);
        let latestFinish = new Array(n).fill(endTime);
        let nameToIdx = {};
        tasksData.forEach((t,i)=>{ nameToIdx[t.name] = i; });
        let revGraph = tasksData.map(()=>[]);
        let outDegree = new Array(n).fill(0);
        tasksData.forEach((t,i)=>{
          t.dependencies.forEach(dep=>{
            let p = nameToIdx[dep.predecessor];
            if(p != null) {
              revGraph[i].push(p);
              outDegree[p]++;
            }
          });
        });
        schedule.forEach((s,i)=>{
          if(outDegree[i]===0){
            latestFinish[i]=s.finish;
            latestStart[i]=s.finish - tasksData[i].duration;
          }
        });
        let queue = [];
        outDegree.forEach((od,i)=>{ if(od===0) queue.push(i); });
        while(queue.length>0) {
          let cur = queue.shift();
          let cLS = latestStart[cur], cLF = latestFinish[cur];
          revGraph[cur].forEach(pred=>{
            let depObj = tasksData[cur].dependencies.find(d=>nameToIdx[d.predecessor]===pred);
            if(!depObj) return;
            let candidate = latestFinish[pred];
            switch(depObj.type) {
              case "FS": candidate = cLS - depObj.lag; break;
              case "SS": candidate = (cLS - depObj.lag) + tasksData[pred].duration; break;
              case "FF": candidate = cLF - depObj.lag; break;
              case "SF": candidate = (cLF - depObj.lag) + tasksData[pred].duration; break;
            }
            if(candidate < latestFinish[pred]) {
              latestFinish[pred] = candidate;
              latestStart[pred] = candidate - tasksData[pred].duration;
            }
            outDegree[pred]--;
            if(outDegree[pred]===0) queue.push(pred);
          });
        }
        let floatArr = new Array(n).fill(0);
        schedule.forEach((s,i)=>{
          let es = s.start, ls = latestStart[i];
          let fl = ls - es; if(fl<0) fl=0;
          floatArr[i] = fl;
        });
        return { floatArr };
      }

      document.getElementById("generateResourceRiskBtn").addEventListener("click", generateResourceRiskInsights);
      function generateResourceRiskInsights() {
        let schedule = computeSchedule();
        let maxFinish = Math.max(...schedule.map(s=>s.finish));
        let dayToResUsage = {};
        for(let d=0; d<=maxFinish; d++){
          dayToResUsage[d] = {};
          resourcesData.forEach(r => { dayToResUsage[d][r.name] = 0; });
        }
        tasksData.forEach((t,i)=>{
          let sDay = Math.floor(schedule[i].start);
          let fDay = Math.ceil(schedule[i].finish);
          t.assignments.forEach(a=>{
            let rName = a.resourceName;
            if(!rName) return;
            let r = resourcesData.find(rr=>rr.name===rName);
            if(!r) return;
            if(r.type!=="Work") return;
            let val = a.value || 100;
            for(let d=sDay; d<fDay; d++){
              dayToResUsage[d][r.name] += val;
            }
          });
        });
        let lines = ["Resource Risk Insights:\n"];
        let riskEntries = [];
        resourcesData.forEach(r=>{
          if(r.type!=="Work") return;
          let mU = r.maxUnits || 100;
          let highestUsage = 0;
          for(let d=0; d<=maxFinish; d++){
            if(dayToResUsage[d][r.name] > highestUsage) highestUsage = dayToResUsage[d][r.name];
          }
          if(highestUsage > mU) {
            let overBy = highestUsage - mU;
            let impact = Math.min(10, Math.floor(5 + (overBy/mU)*5));
            lines.push(`- ${r.name} overallocated (usage=${highestUsage}%, max=${mU}%). (Impact ~ ${impact})`);
            riskEntries.push({ riskName: `${r.name} overallocation`, suggestedRisk: impact });
          } else if(highestUsage >= (0.8*mU)) {
            let impact = 5;
            lines.push(`- ${r.name} usage near capacity (${highestUsage}% of ${mU}%). (Impact ~ ${impact})`);
            riskEntries.push({ riskName: `${r.name} near capacity`, suggestedRisk: impact });
          }
        });
        let workResources = resourcesData.filter(r => r.type==="Work" && r.stdRate>0);
        if(workResources.length > 0) {
          let totalCost = workResources.reduce((sum, r)=> sum + r.stdRate, 0);
          let meanCost = totalCost / workResources.length;
          workResources.forEach(r=>{
            if(r.stdRate > 1.5 * meanCost) {
              let ratio = r.stdRate / meanCost;
              let impact = Math.min(10, Math.floor((ratio - 1) * 10));
              if(impact < 1) impact = 1;
              lines.push(`- ${r.name} has a high cost rate of ${r.stdRate} (mean ${meanCost.toFixed(2)}). (Impact ~ ${impact})`);
              riskEntries.push({ riskName: `${r.name} high cost rate`, suggestedRisk: impact });
            }
          });
        }
        if(lines.length === 1) {
          lines.push("No resource usage above 80% and no disproportionate cost risk => minimal resource risk.");
        }
        let outDiv = document.getElementById("resourceRiskOutput");
        outDiv.innerHTML = `<strong>Textual Risk Insights:</strong><br>` + lines.join("<br>");
        outDiv.style.display = "block";

        let riskJSON = JSON.stringify(riskEntries, null, 2);
        document.getElementById("riskJsonOutput").value = riskJSON;
        document.getElementById("riskJsonOutputContainer").style.display = "block";
      }

      document.getElementById("copyRiskJsonBtn").addEventListener("click", () => {
        const riskJsonOutput = document.getElementById("riskJsonOutput");
        riskJsonOutput.select();
        riskJsonOutput.setSelectionRange(0, 99999);
        navigator.clipboard.writeText(riskJsonOutput.value)
          .then(() => { alert("Risk JSON copied to clipboard!"); })
          .catch(err => { alert("Error copying text: " + err); });
      });
    </script>
  </div>
  <!-- End of Tab 3 -->

  <!-- Tab 4: Risk Assessment (original Tab 3 content, now with id="tab4") -->
  <div id="tab4" class="tab-content">
    <div class="container" id="riskAssessmentContainer">
      <button id="backButton3" onclick="window.location.href='https://projectmanagerhelper.com'">Back to Main Page</button>
      <h1>Risk Register & Assessment</h1>
      <label for="riskJsonInput">Paste Network JSON Output:</label>
      <textarea id="riskJsonInput" placeholder="Paste JSON output from network diagram here..."></textarea>
      <br>
      <button id="loadRiskJsonBtn" class="risk-btn">Load Risk JSON</button>

      <table id="riskTable">
        <thead>
          <tr>
            <th>Risk Name</th>
            <th>Probability (%)</th>
            <th>Impact (1–10)</th>
            <th>Calculate Risk</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows inserted dynamically -->
        </tbody>
      </table>

      <button id="addRiskBtn" class="risk-btn">Add Risk</button>
      <button id="plotBtn" class="risk-btn">Plot Risks</button>
      <button id="exportExcelBtn" class="risk-btn">Export Excel</button>
      <br>

      <label for="riskThreshold">Risk Threshold: </label>
      <input type="range" id="riskThreshold" min="1" max="2" step="0.01" value="1.5">
      <span id="thresholdValue">1.5</span>
      <br>
      <button id="trapRisksBtn" class="risk-btn">Trap Highest Risks</button>

      <div id="mitigationSection" style="display:none; border:1px solid #ccc; padding: 1em; margin-top:1em;">
        <h2>Mitigation Plan for High Risks</h2>
        <div id="mitigationList">
          <!-- Mitigation inputs inserted dynamically -->
        </div>
        <button id="generateReportBtn" class="risk-btn">Generate Risk Report</button>
      </div>

      <div id="heatmapContainer">
        <canvas id="heatmap" width="800" height="500"></canvas>
      </div>

      <script>
        let risks = [];
        const riskTableBody = document.querySelector("#riskTable tbody");
        const addRiskBtn = document.getElementById("addRiskBtn");
        const plotBtn = document.getElementById("plotBtn");
        const exportExcelBtn = document.getElementById("exportExcelBtn");
        const trapRisksBtn = document.getElementById("trapRisksBtn");
        const riskThresholdSlider = document.getElementById("riskThreshold");
        const thresholdValueSpan = document.getElementById("thresholdValue");
        const mitigationSection = document.getElementById("mitigationSection");
        const mitigationList = document.getElementById("mitigationList");
        const generateReportBtn = document.getElementById("generateReportBtn");
        const canvas = document.getElementById("heatmap");
        const ctx = canvas.getContext("2d");
        const CANVAS_WIDTH = canvas.width, CANVAS_HEIGHT = canvas.height;
        const MAX_IMPACT = 10, MAX_PROB = 100;
        const LEFT_MARGIN = 50, RIGHT_MARGIN = 90, TOP_MARGIN = 60, BOTTOM_MARGIN = 50;
        const plotWidth  = CANVAS_WIDTH  - LEFT_MARGIN - RIGHT_MARGIN;
        const plotHeight = CANVAS_HEIGHT - TOP_MARGIN  - BOTTOM_MARGIN;

        createRiskRow();

        addRiskBtn.addEventListener("click", createRiskRow);
        document.getElementById("loadRiskJsonBtn").addEventListener("click", loadRiskJSON);

        function loadRiskJSON() {
          const jsonText = document.getElementById("riskJsonInput").value;
          let activities;
          try {
            activities = JSON.parse(jsonText);
          } catch(e) {
            alert("Invalid JSON. Please check your input.");
            return;
          }
          if (!Array.isArray(activities)) {
            alert("JSON must be an array of activities.");
            return;
          }
          riskTableBody.innerHTML = "";
          activities.forEach(act => {
            const tr = document.createElement("tr");

            const tdName = document.createElement("td");
            const inputName = document.createElement("input");
            inputName.type = "text";
            inputName.value = act.riskName || ("Delay in " + act.name);
            tdName.appendChild(inputName);
            tr.appendChild(tdName);

            const tdProb = document.createElement("td");
            const inputProb = document.createElement("input");
            inputProb.type = "number";
            inputProb.placeholder = "0–100";
            inputProb.min = "0";
            inputProb.max = "100";
            tdProb.appendChild(inputProb);
            tr.appendChild(tdProb);

            const tdImpact = document.createElement("td");
            const inputImpact = document.createElement("input");
            inputImpact.type = "number";
            inputImpact.placeholder = "1–10";
            inputImpact.min = "1";
            inputImpact.max = "10";
            inputImpact.value = act.suggestedRisk || "";
            tdImpact.appendChild(inputImpact);
            tr.appendChild(tdImpact);

            const tdCalc = document.createElement("td");
            const seqBtn = document.createElement("button");
            seqBtn.textContent = "MC Sequential";
            seqBtn.className = "calc-btn";
            seqBtn.title = "Run a Monte Carlo simulation for sequential processes.";
            seqBtn.addEventListener("click", () => {
              window.open("../monte-carlo/index.html", "_blank");
            });
            tdCalc.appendChild(seqBtn);

            const parBtn = document.createElement("button");
            parBtn.textContent = "MC Parallel";
            parBtn.className = "calc-btn";
            parBtn.title = "Run a Monte Carlo simulation for parallel processes.";
            parBtn.addEventListener("click", () => {
              window.open("../advanced-scheduling/index.html", "_blank");
            });
            tdCalc.appendChild(parBtn);

            tr.appendChild(tdCalc);
            riskTableBody.appendChild(tr);
          });
        }

        plotBtn.addEventListener("click", () => {
          gatherRisks();
          drawChart(risks);
        });

        exportExcelBtn.addEventListener("click", async () => {
          gatherRisks();
          const workbook = new ExcelJS.Workbook();
          const worksheet = workbook.addWorksheet("Risk Data");
          worksheet.columns = [
            { header: "Risk Name",       key: "name",       width: 30 },
            { header: "Probability (%)", key: "probability", width: 20 },
            { header: "Impact (1–10)",   key: "impact",      width: 15 }
          ];
          risks.forEach(risk => {
            worksheet.addRow({
              name: risk.name,
              probability: risk.probability,
              impact: risk.impact
            });
          });
          const imgData = canvas.toDataURL("image/png");
          const imageId = workbook.addImage({ base64: imgData, extension: "png" });
          worksheet.addImage(imageId, {
            tl: { col: 0, row: risks.length + 3 },
            ext: { width: 400, height: 250 }
          });
          const buffer = await workbook.xlsx.writeBuffer();
          saveAs(new Blob([buffer]), "Risk_Assessment.xlsx");
        });

        riskThresholdSlider.addEventListener("input", () => {
          thresholdValueSpan.textContent = riskThresholdSlider.value;
          drawChart(risks);
        });

        trapRisksBtn.addEventListener("click", () => {
          gatherRisks();
          const threshold = parseFloat(riskThresholdSlider.value);
          const highRisks = risks.filter(risk => getRiskScore(risk) >= threshold);
          mitigationList.innerHTML = "";
          if (highRisks.length === 0) {
            mitigationList.innerHTML = "<p>No risks meet the threshold.</p>";
          } else {
            highRisks.forEach((risk, idx) => {
              const div = document.createElement("div");
              div.style.borderBottom = "1px solid #eee";
              div.style.marginBottom = "0.5em";
              div.style.paddingBottom = "0.5em";
              div.innerHTML = `<strong>${risk.name}</strong> (Probability: ${risk.probability}%, Impact: ${risk.impact})`;
              const select = document.createElement("select");
              select.innerHTML = `
                <option value="Avoid">Avoid</option>
                <option value="Mitigate">Mitigate</option>
                <option value="Transfer">Transfer</option>
                <option value="Accept">Accept</option>
              `;
              select.style.marginLeft = "1em";
              const input = document.createElement("input");
              input.type = "text";
              input.placeholder = "Enter mitigation details";
              input.style.width = "60%";
              input.style.marginLeft = "1em";
              div.appendChild(select);
              div.appendChild(input);
              div.setAttribute("data-risk-index", idx);
              mitigationList.appendChild(div);
            });
          }
          mitigationSection.style.display = "block";
        });

        generateReportBtn.addEventListener("click", () => {
          const report = {
            risks,
            mitigationPlan: [],
            chartImage: canvas.toDataURL("image/png")
          };
          const mitigationDivs = mitigationList.querySelectorAll("div[data-risk-index]");
          mitigationDivs.forEach(div => {
            const riskName = div.querySelector("strong").textContent;
            const mitigationType = div.querySelector("select").value;
            const details = div.querySelector("input").value;
            report.mitigationPlan.push({ risk: riskName, mitigationType, details });
          });
          let reportHTML = `
            <html>
              <head>
                <title>Risk Report</title>
                <style>
                  body { font-family: sans-serif; margin: 20px; }
                  h1, h2 { color: #333; }
                  ul { list-style-type: disc; margin-left: 20px; }
                </style>
              </head>
              <body>
                <h1>Risk Report</h1>
                <h2>Chart</h2>
                <img src="${report.chartImage}" style="max-width:100%;height:auto;"/>
                <h2>Risk Register</h2>
                <ul>`;
          report.risks.forEach(risk => {
            reportHTML += `<li>${risk.name} (Probability: ${risk.probability}%, Impact: ${risk.impact})</li>`;
          });
          reportHTML += `</ul>
                <h2>Mitigation Plan</h2>
                <ul>`;
          report.mitigationPlan.forEach(plan => {
            reportHTML += `<li><strong>${plan.risk}</strong> – Strategy: ${plan.mitigationType} – Details: ${plan.details}</li>`;
          });
          reportHTML += `
                </ul>
              </body>
            </html>`;
          const reportWindow = window.open("", "_blank");
          reportWindow.document.write(reportHTML);
          reportWindow.document.close();
        });

        function createRiskRow() {
          const tr = document.createElement("tr");

          const tdName = document.createElement("td");
          const inputName = document.createElement("input");
          inputName.type = "text";
          inputName.placeholder = "e.g. Data breach";
          tdName.appendChild(inputName);

          const tdProb = document.createElement("td");
          const inputProb = document.createElement("input");
          inputProb.type = "number";
          inputProb.placeholder = "0–100";
          inputProb.min = "0";
          inputProb.max = "100";
          tdProb.appendChild(inputProb);

          const tdImpact = document.createElement("td");
          const inputImpact = document.createElement("input");
          inputImpact.type = "number";
          inputImpact.placeholder = "1–10";
          inputImpact.min = "1";
          inputImpact.max = "10";
          tdImpact.appendChild(inputImpact);

          const tdCalc = document.createElement("td");
          const seqBtn = document.createElement("button");
          seqBtn.textContent = "MC Sequential";
          seqBtn.className = "calc-btn";
          seqBtn.title = "Run a Monte Carlo simulation for sequential processes.";
          seqBtn.addEventListener("click", () => {
            window.open("../monte-carlo/index.html", "_blank");
          });
          tdCalc.appendChild(seqBtn);

          const parBtn = document.createElement("button");
          parBtn.textContent = "MC Parallel";
          parBtn.className = "calc-btn";
          parBtn.title = "Run a Monte Carlo simulation for parallel processes.";
          parBtn.addEventListener("click", () => {
            window.open("../advanced-scheduling/index.html", "_blank");
          });
          tdCalc.appendChild(parBtn);

          tr.appendChild(tdName);
          tr.appendChild(tdProb);
          tr.appendChild(tdImpact);
          tr.appendChild(tdCalc);
          riskTableBody.appendChild(tr);
        }

        function gatherRisks() {
          risks = [];
          const rows = riskTableBody.querySelectorAll("tr");
          rows.forEach(row => {
            const inputs = row.querySelectorAll("input");
            if (inputs.length === 3) {
              const name = inputs[0].value.trim();
              const probability = parseFloat(inputs[1].value) || 0;
              const impact = parseFloat(inputs[2].value) || 0;
              if(name && probability >= 0 && probability <= 100 && impact >= 1 && impact <= 10) {
                risks.push({ name, probability, impact });
              }
            }
          });
        }

        function getRiskScore(risk) {
          return (risk.probability / MAX_PROB) + (risk.impact / MAX_IMPACT);
        }

        function drawChart(risksArray) {
          ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

          ctx.save();
          ctx.font = "bold 20px sans-serif";
          ctx.textAlign = "center";
          ctx.fillStyle = "#000";
          ctx.fillText("Risk Assessment", CANVAS_WIDTH/2, TOP_MARGIN-15);
          ctx.restore();

          ctx.strokeStyle = "#666";
          ctx.lineWidth = 1;
          ctx.strokeRect(LEFT_MARGIN, TOP_MARGIN, plotWidth, plotHeight);

          // Gradient
          const gradX1 = LEFT_MARGIN, gradY1 = TOP_MARGIN+plotHeight;
          const gradX2 = LEFT_MARGIN+plotWidth, gradY2 = TOP_MARGIN;
          const gradient = ctx.createLinearGradient(gradX1, gradY1, gradX2, gradY2);
          gradient.addColorStop(0, "green");
          gradient.addColorStop(0.2, "yellow");
          gradient.addColorStop(0.5, "orange");
          gradient.addColorStop(1, "red");

          ctx.save();
          ctx.fillStyle = gradient;
          ctx.fillRect(LEFT_MARGIN, TOP_MARGIN, plotWidth, plotHeight);
          ctx.restore();

          // X axis (probability)
          ctx.save();
          ctx.strokeStyle = "#999";
          ctx.fillStyle = "#000";
          ctx.textAlign = "center";
          ctx.font = "12px sans-serif";

          for (let p = 0; p <= MAX_PROB; p += 10) {
            const x = LEFT_MARGIN + (p / MAX_PROB) * plotWidth;
            const y = TOP_MARGIN + plotHeight;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y+5);
            ctx.stroke();
            ctx.fillText(p + "%", x, y+18);
          }
          ctx.font = "14px sans-serif";
          ctx.fillText("Probability (0–100%)", LEFT_MARGIN+plotWidth/2, TOP_MARGIN+plotHeight+40);
          ctx.restore();

          // Y axis (impact)
          ctx.save();
          ctx.strokeStyle = "#999";
          ctx.fillStyle = "#000";
          ctx.textAlign = "right";
          ctx.textBaseline = "middle";
          ctx.font = "12px sans-serif";

          for (let i = 0; i <= MAX_IMPACT; i++) {
            const y = TOP_MARGIN+plotHeight - (i / MAX_IMPACT) * plotHeight;
            ctx.beginPath();
            ctx.moveTo(LEFT_MARGIN, y);
            ctx.lineTo(LEFT_MARGIN-5, y);
            ctx.stroke();
            ctx.fillText(i, LEFT_MARGIN-8, y);
          }
          ctx.save();
          ctx.translate(LEFT_MARGIN-35, TOP_MARGIN+plotHeight/2);
          ctx.rotate(-Math.PI/2);
          ctx.textAlign = "center";
          ctx.font = "14px sans-serif";
          ctx.fillText("Impact (0–10)", 0, 0);
          ctx.restore();
          ctx.restore();

          // Plot each risk
          risksArray.forEach(risk => {
            const x = LEFT_MARGIN + (risk.probability/MAX_PROB)*plotWidth;
            const y = TOP_MARGIN + plotHeight - (risk.impact/MAX_IMPACT)*plotHeight;
            ctx.beginPath();
            ctx.arc(x, y, 4, 0, 2*Math.PI);
            ctx.fillStyle = "#1e90ff";
            ctx.fill();
            ctx.save();
            ctx.translate(x+6, y-4);
            ctx.rotate(-Math.PI/6);
            ctx.fillStyle = "#000";
            ctx.font = "12px sans-serif";
            ctx.fillText(risk.name, 0, 0);
            ctx.restore();
          });

          // Threshold line
          const T = parseFloat(riskThresholdSlider.value);
          const xNormStart = Math.max(0, T-1);
          const xNormEnd = Math.min(1, T);
          const xStart = LEFT_MARGIN + xNormStart * plotWidth;
          const yStart = TOP_MARGIN+plotHeight - (T - xNormStart)*plotHeight;
          const xEnd = LEFT_MARGIN + xNormEnd * plotWidth;
          const yEnd = TOP_MARGIN+plotHeight - (T - xNormEnd)*plotHeight;

          ctx.save();
          ctx.strokeStyle = "black";
          ctx.lineWidth = 2;
          ctx.setLineDash([5,5]);
          ctx.beginPath();
          ctx.moveTo(xStart, yStart);
          ctx.lineTo(xEnd, yEnd);
          ctx.stroke();
          ctx.restore();
        }
      </script>
    </div>
  </div>
  <!-- End of Tab 4 -->

  <!-- Tab Switching Script -->
  <script>
    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        button.classList.add('active');
        document.getElementById(button.getAttribute('data-tab')).classList.add('active');
      });
    });
  </script>
</body>
</html>
